package okhttp3;

import b.f;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import javax.net.ssl.SSLPeerUnverifiedException;
import okhttp3.internal.Util;
import okhttp3.internal.tls.CertificateChainCleaner;

public final class CertificatePinner {
  public static final CertificatePinner DEFAULT = (new Builder()).build();
  
  private final CertificateChainCleaner certificateChainCleaner;
  
  private final Set<Pin> pins;
  
  CertificatePinner(Set<Pin> paramSet, CertificateChainCleaner paramCertificateChainCleaner) {
    this.pins = paramSet;
    this.certificateChainCleaner = paramCertificateChainCleaner;
  }
  
  public static String pin(Certificate paramCertificate) {
    if (paramCertificate instanceof X509Certificate) {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.append("sha256/");
      stringBuilder.append(sha256((X509Certificate)paramCertificate).b());
      return stringBuilder.toString();
    } 
    throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
  }
  
  static f sha1(X509Certificate paramX509Certificate) { return f.a(paramX509Certificate.getPublicKey().getEncoded()).d(); }
  
  static f sha256(X509Certificate paramX509Certificate) { return f.a(paramX509Certificate.getPublicKey().getEncoded()).e(); }
  
  public void check(String paramString, List<Certificate> paramList) {
    StringBuilder stringBuilder1;
    List list2 = findMatchingPins(paramString);
    if (list2.isEmpty())
      return; 
    CertificateChainCleaner certificateChainCleaner1 = this.certificateChainCleaner;
    List<Certificate> list1 = paramList;
    if (certificateChainCleaner1 != null)
      list1 = certificateChainCleaner1.clean(paramList, paramString); 
    int j = list1.size();
    byte b2 = 0;
    byte b1;
    for (b1 = 0; b1 < j; b1++) {
      X509Certificate x509Certificate = (X509Certificate)list1.get(b1);
      int k = list2.size();
      certificateChainCleaner1 = null;
      CertificateChainCleaner certificateChainCleaner2 = certificateChainCleaner1;
      for (byte b = 0; b < k; b++) {
        Pin pin = (Pin)list2.get(b);
        if (pin.hashAlgorithm.equals("sha256/")) {
          f f2 = certificateChainCleaner1;
          if (certificateChainCleaner1 == null)
            f2 = sha256(x509Certificate); 
          f f1 = f2;
          if (pin.hash.equals(f2))
            return; 
        } else if (pin.hashAlgorithm.equals("sha1/")) {
          f f2 = certificateChainCleaner2;
          if (certificateChainCleaner2 == null)
            f2 = sha1(x509Certificate); 
          f f1 = f2;
          if (pin.hash.equals(f2))
            return; 
        } else {
          stringBuilder1 = new StringBuilder();
          stringBuilder1.append("unsupported hashAlgorithm: ");
          stringBuilder1.append(pin.hashAlgorithm);
          throw new AssertionError(stringBuilder1.toString());
        } 
      } 
    } 
    StringBuilder stringBuilder2 = new StringBuilder();
    stringBuilder2.append("Certificate pinning failure!");
    stringBuilder2.append("\n  Peer certificate chain:");
    int i = list1.size();
    for (b1 = 0; b1 < i; b1++) {
      X509Certificate x509Certificate = (X509Certificate)list1.get(b1);
      stringBuilder2.append("\n    ");
      stringBuilder2.append(pin(x509Certificate));
      stringBuilder2.append(": ");
      stringBuilder2.append(x509Certificate.getSubjectDN().getName());
    } 
    stringBuilder2.append("\n  Pinned certificates for ");
    stringBuilder2.append(stringBuilder1);
    stringBuilder2.append(":");
    i = list2.size();
    for (b1 = b2; b1 < i; b1++) {
      Pin pin = (Pin)list2.get(b1);
      stringBuilder2.append("\n    ");
      stringBuilder2.append(pin);
    } 
    throw new SSLPeerUnverifiedException(stringBuilder2.toString());
  }
  
  public void check(String paramString, Certificate... paramVarArgs) { check(paramString, Arrays.asList(paramVarArgs)); }
  
  public boolean equals(Object paramObject) {
    if (paramObject == this)
      return true; 
    if (paramObject instanceof CertificatePinner) {
      CertificateChainCleaner certificateChainCleaner1 = this.certificateChainCleaner;
      paramObject = (CertificatePinner)paramObject;
      if (Util.equal(certificateChainCleaner1, paramObject.certificateChainCleaner) && this.pins.equals(paramObject.pins))
        return true; 
    } 
    return false;
  }
  
  List<Pin> findMatchingPins(String paramString) {
    List list = Collections.emptyList();
    for (Pin pin : this.pins) {
      if (pin.matches(paramString)) {
        List list1 = list;
        if (list.isEmpty())
          list1 = new ArrayList(); 
        list1.add(pin);
        list = list1;
      } 
    } 
    return list;
  }
  
  public int hashCode() {
    boolean bool;
    CertificateChainCleaner certificateChainCleaner1 = this.certificateChainCleaner;
    if (certificateChainCleaner1 != null) {
      bool = certificateChainCleaner1.hashCode();
    } else {
      bool = false;
    } 
    return bool * 31 + this.pins.hashCode();
  }
  
  CertificatePinner withCertificateChainCleaner(CertificateChainCleaner paramCertificateChainCleaner) { return Util.equal(this.certificateChainCleaner, paramCertificateChainCleaner) ? this : new CertificatePinner(this.pins, paramCertificateChainCleaner); }
}
