package okhttp3.internal.http1;

import b.d;
import b.e;
import b.i;
import b.l;
import b.s;
import b.t;
import b.u;
import java.io.EOFException;
import java.io.IOException;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okhttp3.internal.Internal;
import okhttp3.internal.connection.RealConnection;
import okhttp3.internal.connection.StreamAllocation;
import okhttp3.internal.http.HttpCodec;
import okhttp3.internal.http.HttpHeaders;
import okhttp3.internal.http.RealResponseBody;
import okhttp3.internal.http.RequestLine;
import okhttp3.internal.http.StatusLine;

public final class Http1Codec implements HttpCodec {
  private static final int HEADER_LIMIT = 262144;
  
  private static final int STATE_CLOSED = 6;
  
  private static final int STATE_IDLE = 0;
  
  private static final int STATE_OPEN_REQUEST_BODY = 1;
  
  private static final int STATE_OPEN_RESPONSE_BODY = 4;
  
  private static final int STATE_READING_RESPONSE_BODY = 5;
  
  private static final int STATE_READ_RESPONSE_HEADERS = 3;
  
  private static final int STATE_WRITING_REQUEST_BODY = 2;
  
  final OkHttpClient client;
  
  private long headerLimit = 262144L;
  
  final d sink;
  
  final e source;
  
  int state = 0;
  
  final StreamAllocation streamAllocation;
  
  public Http1Codec(OkHttpClient paramOkHttpClient, StreamAllocation paramStreamAllocation, e parame, d paramd) {
    this.client = paramOkHttpClient;
    this.streamAllocation = paramStreamAllocation;
    this.source = parame;
    this.sink = paramd;
  }
  
  private String readHeaderLine() {
    String str = this.source.f(this.headerLimit);
    this.headerLimit -= str.length();
    return str;
  }
  
  public void cancel() {
    RealConnection realConnection = this.streamAllocation.connection();
    if (realConnection != null)
      realConnection.cancel(); 
  }
  
  public s createRequestBody(Request paramRequest, long paramLong) {
    if ("chunked".equalsIgnoreCase(paramRequest.header("Transfer-Encoding")))
      return newChunkedSink(); 
    if (paramLong != -1L)
      return newFixedLengthSink(paramLong); 
    throw new IllegalStateException("Cannot stream a request body without chunked encoding or a known content length!");
  }
  
  void detachTimeout(i parami) {
    u u = parami.a();
    parami.a(u.NONE);
    u.clearDeadline();
    u.clearTimeout();
  }
  
  public void finishRequest() { this.sink.flush(); }
  
  public void flushRequest() { this.sink.flush(); }
  
  public boolean isClosed() { return (this.state == 6); }
  
  public s newChunkedSink() {
    if (this.state == 1) {
      this.state = 2;
      return new ChunkedSink(this);
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("state: ");
    stringBuilder.append(this.state);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public t newChunkedSource(HttpUrl paramHttpUrl) {
    if (this.state == 4) {
      this.state = 5;
      return new ChunkedSource(this, paramHttpUrl);
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("state: ");
    stringBuilder.append(this.state);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public s newFixedLengthSink(long paramLong) {
    if (this.state == 1) {
      this.state = 2;
      return new FixedLengthSink(this, paramLong);
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("state: ");
    stringBuilder.append(this.state);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public t newFixedLengthSource(long paramLong) {
    if (this.state == 4) {
      this.state = 5;
      return new FixedLengthSource(this, paramLong);
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("state: ");
    stringBuilder.append(this.state);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public t newUnknownLengthSource() {
    if (this.state == 4) {
      StreamAllocation streamAllocation1 = this.streamAllocation;
      if (streamAllocation1 != null) {
        this.state = 5;
        streamAllocation1.noNewStreams();
        return new UnknownLengthSource(this);
      } 
      throw new IllegalStateException("streamAllocation == null");
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("state: ");
    stringBuilder.append(this.state);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public ResponseBody openResponseBody(Response paramResponse) {
    this.streamAllocation.eventListener.responseBodyStart(this.streamAllocation.call);
    String str = paramResponse.header("Content-Type");
    if (!HttpHeaders.hasBody(paramResponse))
      return new RealResponseBody(str, 0L, l.a(newFixedLengthSource(0L))); 
    if ("chunked".equalsIgnoreCase(paramResponse.header("Transfer-Encoding")))
      return new RealResponseBody(str, -1L, l.a(newChunkedSource(paramResponse.request().url()))); 
    long l = HttpHeaders.contentLength(paramResponse);
    return (l != -1L) ? new RealResponseBody(str, l, l.a(newFixedLengthSource(l))) : new RealResponseBody(str, -1L, l.a(newUnknownLengthSource()));
  }
  
  public Headers readHeaders() {
    Headers.Builder builder = new Headers.Builder();
    while (true) {
      String str = readHeaderLine();
      if (str.length() != 0) {
        Internal.instance.addLenient(builder, str);
        continue;
      } 
      break;
    } 
    return builder.build();
  }
  
  public Response.Builder readResponseHeaders(boolean paramBoolean) {
    int i = this.state;
    if (i == 1 || i == 3)
      try {
        StatusLine statusLine = StatusLine.parse(readHeaderLine());
        Response.Builder builder = (new Response.Builder()).protocol(statusLine.protocol).code(statusLine.code).message(statusLine.message).headers(readHeaders());
        if (paramBoolean && statusLine.code == 100)
          return null; 
        if (statusLine.code == 100) {
          this.state = 3;
          return builder;
        } 
        this.state = 4;
        return builder;
      } catch (EOFException eOFException) {
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append("unexpected end of stream on ");
        stringBuilder1.append(this.streamAllocation);
        IOException iOException = new IOException(stringBuilder1.toString());
        iOException.initCause(eOFException);
        throw iOException;
      }  
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("state: ");
    stringBuilder.append(this.state);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public void writeRequest(Headers paramHeaders, String paramString) {
    if (this.state == 0) {
      this.sink.b(paramString).b("\r\n");
      byte b = 0;
      int i = paramHeaders.size();
      while (b < i) {
        this.sink.b(paramHeaders.name(b)).b(": ").b(paramHeaders.value(b)).b("\r\n");
        b++;
      } 
      this.sink.b("\r\n");
      this.state = 1;
      return;
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("state: ");
    stringBuilder.append(this.state);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  public void writeRequestHeaders(Request paramRequest) {
    String str = RequestLine.get(paramRequest, this.streamAllocation.connection().route().proxy().type());
    writeRequest(paramRequest.headers(), str);
  }
}
