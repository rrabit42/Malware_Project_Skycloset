package okhttp3.internal.ws;

import b.c;
import b.d;
import b.f;
import b.s;
import java.io.IOException;
import java.util.Random;

final class WebSocketWriter {
  boolean activeWriter;
  
  final c buffer = new c();
  
  final FrameSink frameSink = new FrameSink(this);
  
  final boolean isClient;
  
  private final c.a maskCursor;
  
  private final byte[] maskKey;
  
  final Random random;
  
  final d sink;
  
  final c sinkBuffer;
  
  boolean writerClosed;
  
  WebSocketWriter(boolean paramBoolean, d paramd, Random paramRandom) {
    if (paramd != null) {
      if (paramRandom != null) {
        this.isClient = paramBoolean;
        this.sink = paramd;
        this.sinkBuffer = paramd.b();
        this.random = paramRandom;
        paramRandom = null;
        if (paramBoolean) {
          byte[] arrayOfByte = new byte[4];
        } else {
          paramd = null;
        } 
        this.maskKey = paramd;
        c.a a1 = paramRandom;
        if (paramBoolean)
          a1 = new c.a(); 
        this.maskCursor = a1;
        return;
      } 
      throw new NullPointerException("random == null");
    } 
    throw new NullPointerException("sink == null");
  }
  
  private void writeControlFrame(int paramInt, f paramf) {
    if (!this.writerClosed) {
      int i = paramf.h();
      if (i <= 125L) {
        this.sinkBuffer.b(paramInt | 0x80);
        if (this.isClient) {
          this.sinkBuffer.b(i | 0x80);
          this.random.nextBytes(this.maskKey);
          this.sinkBuffer.b(this.maskKey);
          if (i > 0) {
            long l = this.sinkBuffer.a();
            this.sinkBuffer.a(paramf);
            this.sinkBuffer.a(this.maskCursor);
            this.maskCursor.a(l);
            WebSocketProtocol.toggleMask(this.maskCursor, this.maskKey);
            this.maskCursor.close();
          } 
        } else {
          this.sinkBuffer.b(i);
          this.sinkBuffer.a(paramf);
        } 
        this.sink.flush();
        return;
      } 
      throw new IllegalArgumentException("Payload size must be less than or equal to 125");
    } 
    throw new IOException("closed");
  }
  
  s newMessageSink(int paramInt, long paramLong) {
    if (!this.activeWriter) {
      this.activeWriter = true;
      FrameSink frameSink1 = this.frameSink;
      frameSink1.formatOpcode = paramInt;
      frameSink1.contentLength = paramLong;
      frameSink1.isFirstFrame = true;
      frameSink1.closed = false;
      return frameSink1;
    } 
    throw new IllegalStateException("Another message writer is active. Did you call close()?");
  }
  
  void writeClose(int paramInt, f paramf) {
    f f1 = f.b;
    if (paramInt != 0 || paramf != null) {
      if (paramInt != 0)
        WebSocketProtocol.validateCloseCode(paramInt); 
      c c1 = new c();
      c1.c(paramInt);
      if (paramf != null)
        c1.a(paramf); 
      f1 = c1.q();
    } 
    try {
      writeControlFrame(8, f1);
      return;
    } finally {
      this.writerClosed = true;
    } 
  }
  
  void writeMessageFrame(int paramInt, long paramLong, boolean paramBoolean1, boolean paramBoolean2) {
    if (!this.writerClosed) {
      int j = 0;
      if (!paramBoolean1)
        paramInt = 0; 
      int i = paramInt;
      if (paramBoolean2)
        i = paramInt | 0x80; 
      this.sinkBuffer.b(i);
      paramInt = j;
      if (this.isClient)
        paramInt = 128; 
      if (paramLong <= 125L) {
        i = (int)paramLong;
        this.sinkBuffer.b(i | paramInt);
      } else if (paramLong <= 65535L) {
        this.sinkBuffer.b(paramInt | 0x7E);
        this.sinkBuffer.c((int)paramLong);
      } else {
        this.sinkBuffer.b(paramInt | 0x7F);
        this.sinkBuffer.j(paramLong);
      } 
      if (this.isClient) {
        this.random.nextBytes(this.maskKey);
        this.sinkBuffer.b(this.maskKey);
        if (paramLong > 0L) {
          long l = this.sinkBuffer.a();
          this.sinkBuffer.write(this.buffer, paramLong);
          this.sinkBuffer.a(this.maskCursor);
          this.maskCursor.a(l);
          WebSocketProtocol.toggleMask(this.maskCursor, this.maskKey);
          this.maskCursor.close();
        } 
      } else {
        this.sinkBuffer.write(this.buffer, paramLong);
      } 
      this.sink.e();
      return;
    } 
    throw new IOException("closed");
  }
  
  void writePing(f paramf) { writeControlFrame(9, paramf); }
  
  void writePong(f paramf) { writeControlFrame(10, paramf); }
}
