package okhttp3;

import java.net.Proxy;
import java.net.ProxySelector;
import java.security.GeneralSecurityException;
import java.util.List;
import java.util.Random;
import javax.net.SocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import okhttp3.internal.Internal;
import okhttp3.internal.Util;
import okhttp3.internal.cache.InternalCache;
import okhttp3.internal.platform.Platform;
import okhttp3.internal.tls.CertificateChainCleaner;
import okhttp3.internal.ws.RealWebSocket;

public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory {
  static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS;
  
  static final List<Protocol> DEFAULT_PROTOCOLS = Util.immutableList(new Protocol[] { Protocol.HTTP_2, Protocol.HTTP_1_1 });
  
  final Authenticator authenticator;
  
  final Cache cache;
  
  final int callTimeout;
  
  final CertificateChainCleaner certificateChainCleaner;
  
  final CertificatePinner certificatePinner;
  
  final int connectTimeout;
  
  final ConnectionPool connectionPool;
  
  final List<ConnectionSpec> connectionSpecs;
  
  final CookieJar cookieJar;
  
  final Dispatcher dispatcher;
  
  final Dns dns;
  
  final EventListener.Factory eventListenerFactory;
  
  final boolean followRedirects;
  
  final boolean followSslRedirects;
  
  final HostnameVerifier hostnameVerifier;
  
  final List<Interceptor> interceptors;
  
  final InternalCache internalCache;
  
  final List<Interceptor> networkInterceptors;
  
  final int pingInterval;
  
  final List<Protocol> protocols;
  
  final Proxy proxy;
  
  final Authenticator proxyAuthenticator;
  
  final ProxySelector proxySelector;
  
  final int readTimeout;
  
  final boolean retryOnConnectionFailure;
  
  final SocketFactory socketFactory;
  
  final SSLSocketFactory sslSocketFactory;
  
  final int writeTimeout;
  
  static  {
    DEFAULT_CONNECTION_SPECS = Util.immutableList(new ConnectionSpec[] { ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT });
    Internal.instance = new Object();
  }
  
  public OkHttpClient() { this(new Builder()); }
  
  OkHttpClient(Builder paramBuilder) {
    this.dispatcher = paramBuilder.dispatcher;
    this.proxy = paramBuilder.proxy;
    this.protocols = paramBuilder.protocols;
    this.connectionSpecs = paramBuilder.connectionSpecs;
    this.interceptors = Util.immutableList(paramBuilder.interceptors);
    this.networkInterceptors = Util.immutableList(paramBuilder.networkInterceptors);
    this.eventListenerFactory = paramBuilder.eventListenerFactory;
    this.proxySelector = paramBuilder.proxySelector;
    this.cookieJar = paramBuilder.cookieJar;
    this.cache = paramBuilder.cache;
    this.internalCache = paramBuilder.internalCache;
    this.socketFactory = paramBuilder.socketFactory;
    CertificateChainCleaner certificateChainCleaner1 = this.connectionSpecs.iterator();
    label26: while (true) {
      bool = false;
      while (certificateChainCleaner1.hasNext()) {
        ConnectionSpec connectionSpec = (ConnectionSpec)certificateChainCleaner1.next();
        if (bool || connectionSpec.isTls()) {
          bool = true;
          continue;
        } 
        continue label26;
      } 
      break;
    } 
    if (paramBuilder.sslSocketFactory != null || !bool) {
      this.sslSocketFactory = paramBuilder.sslSocketFactory;
      CertificateChainCleaner certificateChainCleaner2 = paramBuilder.certificateChainCleaner;
    } else {
      X509TrustManager x509TrustManager = Util.platformTrustManager();
      this.sslSocketFactory = newSslSocketFactory(x509TrustManager);
      certificateChainCleaner1 = CertificateChainCleaner.get(x509TrustManager);
    } 
    this.certificateChainCleaner = certificateChainCleaner1;
    if (this.sslSocketFactory != null)
      Platform.get().configureSslSocketFactory(this.sslSocketFactory); 
    this.hostnameVerifier = paramBuilder.hostnameVerifier;
    this.certificatePinner = paramBuilder.certificatePinner.withCertificateChainCleaner(this.certificateChainCleaner);
    this.proxyAuthenticator = paramBuilder.proxyAuthenticator;
    this.authenticator = paramBuilder.authenticator;
    this.connectionPool = paramBuilder.connectionPool;
    this.dns = paramBuilder.dns;
    this.followSslRedirects = paramBuilder.followSslRedirects;
    this.followRedirects = paramBuilder.followRedirects;
    this.retryOnConnectionFailure = paramBuilder.retryOnConnectionFailure;
    this.callTimeout = paramBuilder.callTimeout;
    this.connectTimeout = paramBuilder.connectTimeout;
    this.readTimeout = paramBuilder.readTimeout;
    this.writeTimeout = paramBuilder.writeTimeout;
    this.pingInterval = paramBuilder.pingInterval;
    if (!this.interceptors.contains(null)) {
      if (!this.networkInterceptors.contains(null))
        return; 
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.append("Null network interceptor: ");
      stringBuilder1.append(this.networkInterceptors);
      throw new IllegalStateException(stringBuilder1.toString());
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("Null interceptor: ");
    stringBuilder.append(this.interceptors);
    throw new IllegalStateException(stringBuilder.toString());
  }
  
  private static SSLSocketFactory newSslSocketFactory(X509TrustManager paramX509TrustManager) {
    try {
      SSLContext sSLContext = Platform.get().getSSLContext();
      sSLContext.init(null, new TrustManager[] { paramX509TrustManager }, null);
      return sSLContext.getSocketFactory();
    } catch (GeneralSecurityException paramX509TrustManager) {
      throw Util.assertionError("No System TLS", paramX509TrustManager);
    } 
  }
  
  public Authenticator authenticator() { return this.authenticator; }
  
  public Cache cache() { return this.cache; }
  
  public int callTimeoutMillis() { return this.callTimeout; }
  
  public CertificatePinner certificatePinner() { return this.certificatePinner; }
  
  public int connectTimeoutMillis() { return this.connectTimeout; }
  
  public ConnectionPool connectionPool() { return this.connectionPool; }
  
  public List<ConnectionSpec> connectionSpecs() { return this.connectionSpecs; }
  
  public CookieJar cookieJar() { return this.cookieJar; }
  
  public Dispatcher dispatcher() { return this.dispatcher; }
  
  public Dns dns() { return this.dns; }
  
  public EventListener.Factory eventListenerFactory() { return this.eventListenerFactory; }
  
  public boolean followRedirects() { return this.followRedirects; }
  
  public boolean followSslRedirects() { return this.followSslRedirects; }
  
  public HostnameVerifier hostnameVerifier() { return this.hostnameVerifier; }
  
  public List<Interceptor> interceptors() { return this.interceptors; }
  
  InternalCache internalCache() {
    Cache cache1 = this.cache;
    return (cache1 != null) ? cache1.internalCache : this.internalCache;
  }
  
  public List<Interceptor> networkInterceptors() { return this.networkInterceptors; }
  
  public Builder newBuilder() { return new Builder(this); }
  
  public Call newCall(Request paramRequest) { return RealCall.newRealCall(this, paramRequest, false); }
  
  public WebSocket newWebSocket(Request paramRequest, WebSocketListener paramWebSocketListener) {
    RealWebSocket realWebSocket = new RealWebSocket(paramRequest, paramWebSocketListener, new Random(), this.pingInterval);
    realWebSocket.connect(this);
    return realWebSocket;
  }
  
  public int pingIntervalMillis() { return this.pingInterval; }
  
  public List<Protocol> protocols() { return this.protocols; }
  
  public Proxy proxy() { return this.proxy; }
  
  public Authenticator proxyAuthenticator() { return this.proxyAuthenticator; }
  
  public ProxySelector proxySelector() { return this.proxySelector; }
  
  public int readTimeoutMillis() { return this.readTimeout; }
  
  public boolean retryOnConnectionFailure() { return this.retryOnConnectionFailure; }
  
  public SocketFactory socketFactory() { return this.socketFactory; }
  
  public SSLSocketFactory sslSocketFactory() { return this.sslSocketFactory; }
  
  public int writeTimeoutMillis() { return this.writeTimeout; }
}
