package com.facebook.react.bridge;

import com.facebook.j.a.a;
import com.facebook.systrace.a;
import com.facebook.systrace.b;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

@a
public class JavaModuleWrapper {
  private final ArrayList<MethodDescriptor> mDescs;
  
  private final JSInstance mJSInstance;
  
  private final ArrayList<NativeModule.NativeMethod> mMethods;
  
  private final ModuleHolder mModuleHolder;
  
  public JavaModuleWrapper(JSInstance paramJSInstance, ModuleHolder paramModuleHolder) {
    this.mJSInstance = paramJSInstance;
    this.mModuleHolder = paramModuleHolder;
    this.mMethods = new ArrayList();
    this.mDescs = new ArrayList();
  }
  
  @a
  private void findMethods() {
    a.a(0L, "findMethods");
    HashSet hashSet = new HashSet();
    Class clazz1 = this.mModuleHolder.getModule().getClass();
    Class clazz2 = clazz1.getSuperclass();
    if (ReactModuleWithSpec.class.isAssignableFrom(clazz2))
      clazz1 = clazz2; 
    for (Method method : clazz1.getDeclaredMethods()) {
      ReactMethod reactMethod = (ReactMethod)method.getAnnotation(ReactMethod.class);
      if (reactMethod != null) {
        String str = method.getName();
        if (!hashSet.contains(str)) {
          MethodDescriptor methodDescriptor = new MethodDescriptor(this);
          JavaMethodWrapper javaMethodWrapper = new JavaMethodWrapper(this, method, reactMethod.isBlockingSynchronousMethod());
          methodDescriptor.name = str;
          methodDescriptor.type = javaMethodWrapper.getType();
          if (methodDescriptor.type == "sync") {
            methodDescriptor.signature = javaMethodWrapper.getSignature();
            methodDescriptor.method = method;
          } 
          this.mMethods.add(javaMethodWrapper);
          this.mDescs.add(methodDescriptor);
        } else {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append("Java Module ");
          stringBuilder.append(getName());
          stringBuilder.append(" method name already registered: ");
          stringBuilder.append(str);
          throw new IllegalArgumentException(stringBuilder.toString());
        } 
      } 
    } 
    a.b(0L);
  }
  
  @a
  public NativeMap getConstants() {
    if (!this.mModuleHolder.getHasConstants())
      return null; 
    str = getName();
    b.a(0L, "JavaModuleWrapper.getConstants").a("moduleName", str).a();
    ReactMarker.logMarker(ReactMarkerConstants.GET_CONSTANTS_START, str);
    BaseJavaModule baseJavaModule = getModule();
    a.a(0L, "module.getConstants");
    null = baseJavaModule.getConstants();
    a.b(0L);
    a.a(0L, "create WritableNativeMap");
    ReactMarker.logMarker(ReactMarkerConstants.CONVERT_CONSTANTS_START, str);
    try {
      return Arguments.makeNativeMap(null);
    } finally {
      ReactMarker.logMarker(ReactMarkerConstants.CONVERT_CONSTANTS_END, str);
      a.b(0L);
      ReactMarker.logMarker(ReactMarkerConstants.GET_CONSTANTS_END, str);
      b.a(0L).a();
    } 
  }
  
  @a
  public List<MethodDescriptor> getMethodDescriptors() {
    if (this.mDescs.isEmpty())
      findMethods(); 
    return this.mDescs;
  }
  
  @a
  public BaseJavaModule getModule() { return (BaseJavaModule)this.mModuleHolder.getModule(); }
  
  @a
  public String getName() { return this.mModuleHolder.getName(); }
  
  @a
  public void invoke(int paramInt, ReadableNativeArray paramReadableNativeArray) {
    ArrayList arrayList = this.mMethods;
    if (arrayList != null) {
      if (paramInt >= arrayList.size())
        return; 
      ((NativeModule.NativeMethod)this.mMethods.get(paramInt)).invoke(this.mJSInstance, paramReadableNativeArray);
    } 
  }
}
