package com.facebook.react.bridge;

import com.facebook.d.b.c;
import com.facebook.d.c.a;
import com.facebook.i.a.a;
import com.facebook.systrace.b;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class JavaMethodWrapper implements NativeModule.NativeMethod {
  private static final ArgumentExtractor<ReadableArray> ARGUMENT_EXTRACTOR_ARRAY;
  
  private static final ArgumentExtractor<Boolean> ARGUMENT_EXTRACTOR_BOOLEAN = new Object();
  
  private static final ArgumentExtractor<Callback> ARGUMENT_EXTRACTOR_CALLBACK;
  
  private static final ArgumentExtractor<Double> ARGUMENT_EXTRACTOR_DOUBLE = new Object();
  
  private static final ArgumentExtractor<Dynamic> ARGUMENT_EXTRACTOR_DYNAMIC;
  
  private static final ArgumentExtractor<Float> ARGUMENT_EXTRACTOR_FLOAT = new Object();
  
  private static final ArgumentExtractor<Integer> ARGUMENT_EXTRACTOR_INTEGER = new Object();
  
  private static final ArgumentExtractor<ReadableMap> ARGUMENT_EXTRACTOR_MAP;
  
  private static final ArgumentExtractor<Promise> ARGUMENT_EXTRACTOR_PROMISE;
  
  private static final ArgumentExtractor<String> ARGUMENT_EXTRACTOR_STRING = new Object();
  
  private static final boolean DEBUG;
  
  private ArgumentExtractor[] mArgumentExtractors;
  
  private Object[] mArguments;
  
  private boolean mArgumentsProcessed = false;
  
  private int mJSArgumentsNeeded;
  
  private final Method mMethod;
  
  private final JavaModuleWrapper mModuleWrapper;
  
  private final int mParamLength;
  
  private final Class[] mParameterTypes;
  
  private String mSignature;
  
  private String mType = "async";
  
  static  {
    ARGUMENT_EXTRACTOR_ARRAY = new Object();
    ARGUMENT_EXTRACTOR_DYNAMIC = new Object();
    ARGUMENT_EXTRACTOR_MAP = new Object();
    ARGUMENT_EXTRACTOR_CALLBACK = new Object();
    ARGUMENT_EXTRACTOR_PROMISE = new Object();
    DEBUG = c.a().a(a.d);
  }
  
  public JavaMethodWrapper(JavaModuleWrapper paramJavaModuleWrapper, Method paramMethod, boolean paramBoolean) {
    this.mModuleWrapper = paramJavaModuleWrapper;
    this.mMethod = paramMethod;
    this.mMethod.setAccessible(true);
    this.mParameterTypes = this.mMethod.getParameterTypes();
    String str = this.mParameterTypes;
    this.mParamLength = str.length;
    if (paramBoolean) {
      str = "sync";
    } else {
      int i = this.mParamLength;
      if (i > 0 && str[i - true] == Promise.class) {
        str = "promise";
      } else {
        return;
      } 
    } 
    this.mType = str;
  }
  
  private ArgumentExtractor[] buildArgumentExtractors(Class[] paramArrayOfClass) {
    ArgumentExtractor[] arrayOfArgumentExtractor = new ArgumentExtractor[paramArrayOfClass.length];
    for (int i = 0; i < paramArrayOfClass.length; i += arrayOfArgumentExtractor[i].getJSArgumentsNeeded()) {
      Class clazz = paramArrayOfClass[i];
      if (clazz == Boolean.class || clazz == boolean.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_BOOLEAN;
      } else if (clazz == Integer.class || clazz == int.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_INTEGER;
      } else if (clazz == Double.class || clazz == double.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_DOUBLE;
      } else if (clazz == Float.class || clazz == float.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_FLOAT;
      } else if (clazz == String.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_STRING;
      } else if (clazz == Callback.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_CALLBACK;
      } else if (clazz == Promise.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_PROMISE;
        int j = paramArrayOfClass.length;
        boolean bool = true;
        if (i != j - 1)
          bool = false; 
        a.a(bool, "Promise must be used as last parameter only");
      } else if (clazz == ReadableMap.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_MAP;
      } else if (clazz == ReadableArray.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_ARRAY;
      } else if (clazz == Dynamic.class) {
        arrayOfArgumentExtractor[i] = ARGUMENT_EXTRACTOR_DYNAMIC;
      } else {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Got unknown argument class: ");
        stringBuilder.append(clazz.getSimpleName());
        throw new RuntimeException(stringBuilder.toString());
      } 
    } 
    return arrayOfArgumentExtractor;
  }
  
  private String buildSignature(Method paramMethod, Class[] paramArrayOfClass, boolean paramBoolean) {
    StringBuilder stringBuilder = new StringBuilder(paramArrayOfClass.length + 2);
    if (paramBoolean) {
      stringBuilder.append(returnTypeToChar(paramMethod.getReturnType()));
      stringBuilder.append('.');
    } else {
      stringBuilder.append("v.");
    } 
    byte b;
    for (b = 0; b < paramArrayOfClass.length; b++) {
      Class clazz = paramArrayOfClass[b];
      if (clazz == Promise.class) {
        int i = paramArrayOfClass.length;
        paramBoolean = true;
        if (b != i - 1)
          paramBoolean = false; 
        a.a(paramBoolean, "Promise must be used as last parameter only");
      } 
      stringBuilder.append(paramTypeToChar(clazz));
    } 
    return stringBuilder.toString();
  }
  
  private int calculateJSArgumentsNeeded() {
    ArgumentExtractor[] arrayOfArgumentExtractor = (ArgumentExtractor[])a.a(this.mArgumentExtractors);
    int j = arrayOfArgumentExtractor.length;
    byte b = 0;
    int i = 0;
    while (b < j) {
      i += arrayOfArgumentExtractor[b].getJSArgumentsNeeded();
      b++;
    } 
    return i;
  }
  
  private static char commonTypeToChar(Class paramClass) { return (paramClass == boolean.class) ? 'z' : ((paramClass == Boolean.class) ? 'Z' : ((paramClass == int.class) ? 'i' : ((paramClass == Integer.class) ? 'I' : ((paramClass == double.class) ? 'd' : ((paramClass == Double.class) ? 'D' : ((paramClass == float.class) ? 'f' : ((paramClass == Float.class) ? 'F' : ((paramClass == String.class) ? 'S' : Character.MIN_VALUE)))))))); }
  
  private String getAffectedRange(int paramInt1, int paramInt2) {
    if (paramInt2 > 1) {
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.append("");
      stringBuilder1.append(paramInt1);
      stringBuilder1.append("-");
      stringBuilder1.append(paramInt1 + paramInt2 - 1);
      return stringBuilder1.toString();
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("");
    stringBuilder.append(paramInt1);
    return stringBuilder.toString();
  }
  
  private static char paramTypeToChar(Class paramClass) {
    char c = commonTypeToChar(paramClass);
    if (c != '\000')
      return c; 
    if (paramClass == Callback.class)
      return 'X'; 
    if (paramClass == Promise.class)
      return 'P'; 
    if (paramClass == ReadableMap.class)
      return 'M'; 
    if (paramClass == ReadableArray.class)
      return 'A'; 
    if (paramClass == Dynamic.class)
      return 'Y'; 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("Got unknown param class: ");
    stringBuilder.append(paramClass.getSimpleName());
    throw new RuntimeException(stringBuilder.toString());
  }
  
  private void processArguments() {
    if (this.mArgumentsProcessed)
      return; 
    null = b.a(0L, "processArguments");
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(this.mModuleWrapper.getName());
    stringBuilder.append(".");
    stringBuilder.append(this.mMethod.getName());
    null.a("method", stringBuilder.toString()).a();
    try {
      this.mArgumentsProcessed = true;
      this.mArgumentExtractors = buildArgumentExtractors(this.mParameterTypes);
      this.mSignature = buildSignature(this.mMethod, this.mParameterTypes, this.mType.equals("sync"));
      this.mArguments = new Object[this.mParameterTypes.length];
      this.mJSArgumentsNeeded = calculateJSArgumentsNeeded();
      return;
    } finally {
      b.a(0L).a();
    } 
  }
  
  private static char returnTypeToChar(Class paramClass) {
    char c = commonTypeToChar(paramClass);
    if (c != '\000')
      return c; 
    if (paramClass == void.class)
      return 'v'; 
    if (paramClass == WritableMap.class)
      return 'M'; 
    if (paramClass == WritableArray.class)
      return 'A'; 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("Got unknown return class: ");
    stringBuilder.append(paramClass.getSimpleName());
    throw new RuntimeException(stringBuilder.toString());
  }
  
  public Method getMethod() { return this.mMethod; }
  
  public String getSignature() {
    if (!this.mArgumentsProcessed)
      processArguments(); 
    return (String)a.a(this.mSignature);
  }
  
  public String getType() { return this.mType; }
  
  public void invoke(JSInstance paramJSInstance, ReadableArray paramReadableArray) {
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append(this.mModuleWrapper.getName());
    stringBuilder.append(".");
    stringBuilder.append(this.mMethod.getName());
    String str = stringBuilder.toString();
    b.a(0L, "callJavaModuleMethod").a("method", str).a();
    boolean bool = DEBUG;
    byte b = 0;
    if (bool)
      c.a().a(a.d, "JS->Java: %s.%s()", new Object[] { this.mModuleWrapper.getName(), this.mMethod.getName() }); 
    try {
      if (!this.mArgumentsProcessed)
        processArguments(); 
      if (this.mArguments != null && this.mArgumentExtractors != null) {
        StringBuilder stringBuilder2;
        int i = this.mJSArgumentsNeeded;
        int j = paramReadableArray.size();
        if (i == j) {
          i = 0;
          try {
            while (b < this.mArgumentExtractors.length) {
              this.mArguments[b] = this.mArgumentExtractors[b].extractArgument(paramJSInstance, paramReadableArray, i);
              j = this.mArgumentExtractors[b].getJSArgumentsNeeded();
              i += j;
              b++;
            } 
            try {
              this.mMethod.invoke(this.mModuleWrapper.getModule(), this.mArguments);
              return;
            } catch (IllegalArgumentException paramJSInstance) {
              stringBuilder2 = new StringBuilder();
              stringBuilder2.append("Could not invoke ");
              stringBuilder2.append(str);
              throw new RuntimeException(stringBuilder2.toString(), paramJSInstance);
            } catch (IllegalAccessException paramJSInstance) {
              stringBuilder2 = new StringBuilder();
              stringBuilder2.append("Could not invoke ");
              stringBuilder2.append(str);
              throw new RuntimeException(stringBuilder2.toString(), paramJSInstance);
            } catch (InvocationTargetException paramJSInstance) {
              if (paramJSInstance.getCause() instanceof RuntimeException)
                throw (RuntimeException)paramJSInstance.getCause(); 
              stringBuilder2 = new StringBuilder();
              stringBuilder2.append("Could not invoke ");
              stringBuilder2.append(str);
              throw new RuntimeException(stringBuilder2.toString(), paramJSInstance);
            } 
          } catch (UnexpectedNativeTypeException paramJSInstance) {
            stringBuilder2 = new StringBuilder();
            stringBuilder2.append(paramJSInstance.getMessage());
            stringBuilder2.append(" (constructing arguments for ");
            stringBuilder2.append(str);
            stringBuilder2.append(" at argument index ");
            stringBuilder2.append(getAffectedRange(i, this.mArgumentExtractors[b].getJSArgumentsNeeded()));
            stringBuilder2.append(")");
            throw new NativeArgumentsParseException(stringBuilder2.toString(), paramJSInstance);
          } 
        } 
        StringBuilder stringBuilder1 = new StringBuilder();
        stringBuilder1.append(str);
        stringBuilder1.append(" got ");
        stringBuilder1.append(stringBuilder2.size());
        stringBuilder1.append(" arguments, expected ");
        stringBuilder1.append(this.mJSArgumentsNeeded);
        throw new NativeArgumentsParseException(stringBuilder1.toString());
      } 
      throw new Error("processArguments failed");
    } finally {
      b.a(0L).a();
    } 
  }
}
