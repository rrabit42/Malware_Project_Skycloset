package com.facebook.react.views.art;

import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.DashPathEffect;
import android.graphics.LinearGradient;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.RectF;
import android.graphics.Shader;
import com.facebook.common.e.a;
import com.facebook.react.bridge.JSApplicationIllegalArgumentException;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.uimanager.a.a;

public class b extends f {
  protected Path a;
  
  private float[] d;
  
  private float[] e;
  
  private float[] f;
  
  private float g = 1.0F;
  
  private int h = 1;
  
  private int i = 1;
  
  private float a(float paramFloat1, float paramFloat2) {
    float f1 = paramFloat1 % paramFloat2;
    paramFloat1 = f1;
    if (f1 < 0.0F)
      paramFloat1 = f1 + paramFloat2; 
    return paramFloat1;
  }
  
  private Path a(float[] paramArrayOfFloat) {
    Path path = new Path();
    path.moveTo(0.0F, 0.0F);
    int j = 0;
    while (j < paramArrayOfFloat.length) {
      StringBuilder stringBuilder6;
      float f7;
      StringBuilder stringBuilder5;
      float f6;
      float f5;
      StringBuilder stringBuilder4;
      float f4;
      StringBuilder stringBuilder3;
      float f3;
      float f1;
      StringBuilder stringBuilder1;
      int k = j + true;
      j = (int)paramArrayOfFloat[j];
      switch (j) {
        default:
          stringBuilder1 = new StringBuilder();
          stringBuilder1.append("Unrecognized drawing instruction ");
          stringBuilder1.append(j);
          throw new JSApplicationIllegalArgumentException(stringBuilder1.toString());
        case 4:
          j = k + true;
          f3 = stringBuilder1[k] * this.c;
          k = j + 1;
          f4 = stringBuilder1[j] * this.c;
          j = k + 1;
          f5 = stringBuilder1[k] * this.c;
          m = j + 1;
          f6 = (float)Math.toDegrees(stringBuilder1[j]);
          k = m + 1;
          f1 = (float)Math.toDegrees(stringBuilder1[m]);
          if (stringBuilder1[k] != 1.0F) {
            j = 1;
          } else {
            j = 0;
          } 
          f1 -= f6;
          if (Math.abs(f1) >= 360.0F) {
            Path.Direction direction;
            if (j != 0) {
              direction = Path.Direction.CCW;
            } else {
              direction = Path.Direction.CW;
            } 
            path.addCircle(f3, f4, f5, direction);
          } else {
            float f8 = a(f1, 360.0F);
            f1 = f8;
            if (j != 0) {
              f1 = f8;
              if (f8 < 360.0F)
                f1 = (360.0F - f8) * -1.0F; 
            } 
            path.arcTo(new RectF(f3 - f5, f4 - f5, f3 + f5, f4 + f5), f6, f1);
          } 
          j = k + 1;
          continue;
        case 3:
          j = k + 1;
          stringBuilder2 = stringBuilder1[k];
          f2 = this.c;
          k = j + 1;
          stringBuilder3 = stringBuilder1[j];
          f4 = this.c;
          j = k + 1;
          stringBuilder4 = stringBuilder1[k];
          f6 = this.c;
          k = j + 1;
          stringBuilder5 = stringBuilder1[j];
          f7 = this.c;
          j = k + 1;
          stringBuilder6 = stringBuilder1[k];
          path.cubicTo(stringBuilder2 * f2, f4 * stringBuilder3, f6 * stringBuilder4, f7 * stringBuilder5, this.c * stringBuilder6, stringBuilder1[j] * this.c);
          j++;
          continue;
        case 2:
          m = k + 1;
          stringBuilder2 = stringBuilder1[k];
          f2 = this.c;
          j = m + 1;
          path.lineTo(stringBuilder2 * f2, stringBuilder1[m] * this.c);
          continue;
        case 1:
          path.close();
          j = k;
          continue;
        case 0:
          break;
      } 
      int m = k + 1;
      StringBuilder stringBuilder2 = stringBuilder1[k];
      float f2 = this.c;
      j = m + 1;
      path.moveTo(stringBuilder2 * f2, stringBuilder1[m] * this.c);
    } 
    return path;
  }
  
  public void a(Canvas paramCanvas, Paint paramPaint, float paramFloat) {
    paramFloat *= this.b;
    if (paramFloat > 0.01F) {
      a(paramCanvas);
      if (this.a != null) {
        if (b(paramPaint, paramFloat))
          paramCanvas.drawPath(this.a, paramPaint); 
        if (a(paramPaint, paramFloat))
          paramCanvas.drawPath(this.a, paramPaint); 
        b(paramCanvas);
      } else {
        throw new JSApplicationIllegalArgumentException("Shapes should have a valid path (d) prop");
      } 
    } 
    e();
  }
  
  protected boolean a(Paint paramPaint, float paramFloat) {
    if (this.g != 0.0F) {
      float[] arrayOfFloat = this.d;
      if (arrayOfFloat != null) {
        Paint.Join join;
        Paint.Cap cap;
        StringBuilder stringBuilder;
        if (arrayOfFloat.length == 0)
          return false; 
        paramPaint.reset();
        paramPaint.setFlags(1);
        paramPaint.setStyle(Paint.Style.STROKE);
        switch (this.h) {
          default:
            stringBuilder = new StringBuilder();
            stringBuilder.append("strokeCap ");
            stringBuilder.append(this.h);
            stringBuilder.append(" unrecognized");
            throw new JSApplicationIllegalArgumentException(stringBuilder.toString());
          case 2:
            cap = Paint.Cap.SQUARE;
            break;
          case 1:
            cap = Paint.Cap.ROUND;
            break;
          case 0:
            cap = Paint.Cap.BUTT;
            break;
        } 
        stringBuilder.setStrokeCap(cap);
        switch (this.i) {
          default:
            stringBuilder = new StringBuilder();
            stringBuilder.append("strokeJoin ");
            stringBuilder.append(this.i);
            stringBuilder.append(" unrecognized");
            throw new JSApplicationIllegalArgumentException(stringBuilder.toString());
          case 2:
            join = Paint.Join.BEVEL;
            break;
          case 1:
            join = Paint.Join.ROUND;
            break;
          case 0:
            join = Paint.Join.MITER;
            break;
        } 
        stringBuilder.setStrokeJoin(join);
        stringBuilder.setStrokeWidth(this.g * this.c);
        float[] arrayOfFloat1 = this.d;
        if (arrayOfFloat1.length > 3) {
          paramFloat = arrayOfFloat1[3] * paramFloat * 255.0F;
        } else {
          paramFloat *= 255.0F;
        } 
        int j = (int)paramFloat;
        arrayOfFloat1 = this.d;
        stringBuilder.setARGB(j, (int)(arrayOfFloat1[0] * 255.0F), (int)(arrayOfFloat1[1] * 255.0F), (int)(arrayOfFloat1[2] * 255.0F));
        arrayOfFloat1 = this.f;
        if (arrayOfFloat1 != null && arrayOfFloat1.length > 0)
          stringBuilder.setPathEffect(new DashPathEffect(arrayOfFloat1, 0.0F)); 
        return true;
      } 
    } 
    return false;
  }
  
  protected boolean b(Paint paramPaint, float paramFloat) {
    float[] arrayOfFloat = this.e;
    int j = 0;
    if (arrayOfFloat != null && arrayOfFloat.length > 0) {
      float[] arrayOfFloat1;
      float f7;
      float f6;
      float f5;
      float f4;
      float f3;
      float f2;
      float f1;
      StringBuilder stringBuilder;
      paramPaint.reset();
      paramPaint.setFlags(1);
      paramPaint.setStyle(Paint.Style.FILL);
      arrayOfFloat = this.e;
      int k = (int)arrayOfFloat[0];
      switch (k) {
        default:
          stringBuilder = new StringBuilder();
          stringBuilder.append("ART: Color type ");
          stringBuilder.append(k);
          stringBuilder.append(" not supported!");
          a.c("ReactNative", stringBuilder.toString());
          return true;
        case 1:
          if (arrayOfFloat.length < 5) {
            stringBuilder = new StringBuilder();
            stringBuilder.append("[ARTShapeShadowNode setupFillPaint] expects 5 elements, received ");
            stringBuilder.append(this.e.length);
            a.c("ReactNative", stringBuilder.toString());
            return false;
          } 
          paramFloat = arrayOfFloat[1];
          f1 = this.c;
          f2 = this.e[2];
          f3 = this.c;
          f4 = this.e[3];
          f5 = this.c;
          f6 = this.e[4];
          f7 = this.c;
          k = (this.e.length - 5) / 5;
          if (k > 0) {
            int[] arrayOfInt = new int[k];
            arrayOfFloat1 = new float[k];
            while (j < k) {
              float[] arrayOfFloat2 = this.e;
              arrayOfFloat1[j] = arrayOfFloat2[k * 4 + 5 + j];
              int m = j * 4 + 5;
              int n = (int)(arrayOfFloat2[m + 0] * 255.0F);
              int i1 = (int)(arrayOfFloat2[m + 1] * 255.0F);
              int i2 = (int)(arrayOfFloat2[m + 2] * 255.0F);
              arrayOfInt[j] = Color.argb((int)(arrayOfFloat2[m + 3] * 255.0F), n, i1, i2);
              j++;
            } 
          } else {
            arrayOfFloat = null;
            arrayOfFloat1 = arrayOfFloat;
          } 
          stringBuilder.setShader(new LinearGradient(paramFloat * f1, f2 * f3, f4 * f5, f6 * f7, arrayOfFloat, arrayOfFloat1, Shader.TileMode.CLAMP));
          return true;
        case 0:
          break;
      } 
      if (arrayOfFloat.length > 4) {
        paramFloat = arrayOfFloat[4] * paramFloat * 255.0F;
      } else {
        paramFloat *= 255.0F;
      } 
      k = (int)paramFloat;
      arrayOfFloat = this.e;
      stringBuilder.setARGB(k, (int)(arrayOfFloat[1] * 255.0F), (int)(arrayOfFloat[2] * 255.0F), (int)(arrayOfFloat[3] * 255.0F));
      return true;
    } 
    return false;
  }
  
  @a(a = "fill")
  public void setFill(ReadableArray paramReadableArray) {
    this.e = g.a(paramReadableArray);
    D();
  }
  
  @a(a = "d")
  public void setShapePath(ReadableArray paramReadableArray) {
    this.a = a(g.a(paramReadableArray));
    D();
  }
  
  @a(a = "stroke")
  public void setStroke(ReadableArray paramReadableArray) {
    this.d = g.a(paramReadableArray);
    D();
  }
  
  @a(a = "strokeCap", e = 1)
  public void setStrokeCap(int paramInt) {
    this.h = paramInt;
    D();
  }
  
  @a(a = "strokeDash")
  public void setStrokeDash(ReadableArray paramReadableArray) {
    this.f = g.a(paramReadableArray);
    D();
  }
  
  @a(a = "strokeJoin", e = 1)
  public void setStrokeJoin(int paramInt) {
    this.i = paramInt;
    D();
  }
  
  @a(a = "strokeWidth", d = 1.0F)
  public void setStrokeWidth(float paramFloat) {
    this.g = paramFloat;
    D();
  }
}
