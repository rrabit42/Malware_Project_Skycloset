package com.facebook.react.modules.netinfo;

import android.annotation.SuppressLint;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.support.v4.c.a;
import com.facebook.react.bridge.LifecycleEventListener;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.module.a.a;
import com.facebook.react.modules.core.DeviceEventManagerModule;

@a(a = "NetInfo")
@SuppressLint({"MissingPermission"})
public class NetInfoModule extends ReactContextBaseJavaModule implements LifecycleEventListener {
  private static final String CONNECTION_TYPE_BLUETOOTH = "bluetooth";
  
  private static final String CONNECTION_TYPE_CELLULAR = "cellular";
  
  private static final String CONNECTION_TYPE_ETHERNET = "ethernet";
  
  private static final String CONNECTION_TYPE_NONE = "none";
  
  private static final String CONNECTION_TYPE_NONE_DEPRECATED = "NONE";
  
  private static final String CONNECTION_TYPE_UNKNOWN = "unknown";
  
  private static final String CONNECTION_TYPE_UNKNOWN_DEPRECATED = "UNKNOWN";
  
  private static final String CONNECTION_TYPE_WIFI = "wifi";
  
  private static final String CONNECTION_TYPE_WIMAX = "wimax";
  
  private static final String EFFECTIVE_CONNECTION_TYPE_2G = "2g";
  
  private static final String EFFECTIVE_CONNECTION_TYPE_3G = "3g";
  
  private static final String EFFECTIVE_CONNECTION_TYPE_4G = "4g";
  
  private static final String EFFECTIVE_CONNECTION_TYPE_UNKNOWN = "unknown";
  
  private static final String ERROR_MISSING_PERMISSION = "E_MISSING_PERMISSION";
  
  private static final String MISSING_PERMISSION_MESSAGE = "To use NetInfo on Android, add the following to your AndroidManifest.xml:\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />";
  
  public static final String NAME = "NetInfo";
  
  private String mConnectionType = "unknown";
  
  private final a mConnectivityBroadcastReceiver;
  
  private String mConnectivityDeprecated = "UNKNOWN";
  
  private final ConnectivityManager mConnectivityManager;
  
  private String mEffectiveConnectionType = "unknown";
  
  private boolean mNoNetworkPermission = false;
  
  public NetInfoModule(ReactApplicationContext paramReactApplicationContext) {
    super(paramReactApplicationContext);
    this.mConnectivityManager = (ConnectivityManager)paramReactApplicationContext.getSystemService("connectivity");
    this.mConnectivityBroadcastReceiver = new a(this, null);
  }
  
  private WritableMap createConnectivityEventMap() {
    WritableNativeMap writableNativeMap = new WritableNativeMap();
    writableNativeMap.putString("network_info", this.mConnectivityDeprecated);
    writableNativeMap.putString("connectionType", this.mConnectionType);
    writableNativeMap.putString("effectiveConnectionType", this.mEffectiveConnectionType);
    return writableNativeMap;
  }
  
  private String getCurrentConnectionType() {
    try {
      NetworkInfo networkInfo = this.mConnectivityManager.getActiveNetworkInfo();
      if (networkInfo == null || !networkInfo.isConnected())
        return "NONE"; 
      if (ConnectivityManager.isNetworkTypeValid(networkInfo.getType()))
        return networkInfo.getTypeName().toUpperCase(); 
    } catch (SecurityException securityException) {
      this.mNoNetworkPermission = true;
      return "UNKNOWN";
    } 
    return "UNKNOWN";
  }
  
  private String getEffectiveConnectionType(NetworkInfo paramNetworkInfo) {
    switch (paramNetworkInfo.getSubtype()) {
      default:
        return "unknown";
      case 13:
      case 15:
        return "4g";
      case 3:
      case 5:
      case 6:
      case 8:
      case 9:
      case 10:
      case 12:
      case 14:
        return "3g";
      case 1:
      case 2:
      case 4:
      case 7:
      case 11:
        break;
    } 
    return "2g";
  }
  
  private void registerReceiver() {
    IntentFilter intentFilter = new IntentFilter();
    intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
    getReactApplicationContext().registerReceiver(this.mConnectivityBroadcastReceiver, intentFilter);
    this.mConnectivityBroadcastReceiver.a(true);
    updateAndSendConnectionType();
  }
  
  private void sendConnectivityChangedEvent() { ((DeviceEventManagerModule.RCTDeviceEventEmitter)getReactApplicationContext().getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)).emit("networkStatusDidChange", createConnectivityEventMap()); }
  
  private void unregisterReceiver() {
    if (this.mConnectivityBroadcastReceiver.a()) {
      getReactApplicationContext().unregisterReceiver(this.mConnectivityBroadcastReceiver);
      this.mConnectivityBroadcastReceiver.a(false);
    } 
  }
  
  private void updateAndSendConnectionType() { // Byte code:
    //   0: ldc 'unknown'
    //   2: astore_2
    //   3: aload_0
    //   4: getfield mConnectivityManager : Landroid/net/ConnectivityManager;
    //   7: invokevirtual getActiveNetworkInfo : ()Landroid/net/NetworkInfo;
    //   10: astore_1
    //   11: aload_1
    //   12: ifnull -> 100
    //   15: aload_1
    //   16: invokevirtual isConnected : ()Z
    //   19: ifne -> 25
    //   22: goto -> 100
    //   25: aload_1
    //   26: invokevirtual getType : ()I
    //   29: tableswitch default -> 176, 0 -> 84, 1 -> 200, 2 -> 176, 3 -> 176, 4 -> 84, 5 -> 176, 6 -> 194, 7 -> 188, 8 -> 176, 9 -> 182
    //   84: aload_0
    //   85: aload_1
    //   86: invokespecial getEffectiveConnectionType : (Landroid/net/NetworkInfo;)Ljava/lang/String;
    //   89: astore_1
    //   90: ldc 'cellular'
    //   92: astore_3
    //   93: aload_1
    //   94: astore_2
    //   95: aload_3
    //   96: astore_1
    //   97: goto -> 114
    //   100: ldc 'none'
    //   102: astore_1
    //   103: goto -> 114
    //   106: aload_0
    //   107: iconst_1
    //   108: putfield mNoNetworkPermission : Z
    //   111: ldc 'unknown'
    //   113: astore_1
    //   114: aload_0
    //   115: invokespecial getCurrentConnectionType : ()Ljava/lang/String;
    //   118: astore_3
    //   119: aload_1
    //   120: aload_0
    //   121: getfield mConnectionType : Ljava/lang/String;
    //   124: invokevirtual equalsIgnoreCase : (Ljava/lang/String;)Z
    //   127: ifeq -> 152
    //   130: aload_2
    //   131: aload_0
    //   132: getfield mEffectiveConnectionType : Ljava/lang/String;
    //   135: invokevirtual equalsIgnoreCase : (Ljava/lang/String;)Z
    //   138: ifeq -> 152
    //   141: aload_3
    //   142: aload_0
    //   143: getfield mConnectivityDeprecated : Ljava/lang/String;
    //   146: invokevirtual equalsIgnoreCase : (Ljava/lang/String;)Z
    //   149: ifne -> 171
    //   152: aload_0
    //   153: aload_1
    //   154: putfield mConnectionType : Ljava/lang/String;
    //   157: aload_0
    //   158: aload_2
    //   159: putfield mEffectiveConnectionType : Ljava/lang/String;
    //   162: aload_0
    //   163: aload_3
    //   164: putfield mConnectivityDeprecated : Ljava/lang/String;
    //   167: aload_0
    //   168: invokespecial sendConnectivityChangedEvent : ()V
    //   171: return
    //   172: astore_1
    //   173: goto -> 106
    //   176: ldc 'unknown'
    //   178: astore_1
    //   179: goto -> 114
    //   182: ldc 'ethernet'
    //   184: astore_1
    //   185: goto -> 114
    //   188: ldc 'bluetooth'
    //   190: astore_1
    //   191: goto -> 114
    //   194: ldc 'wimax'
    //   196: astore_1
    //   197: goto -> 114
    //   200: ldc 'wifi'
    //   202: astore_1
    //   203: goto -> 114
    // Exception table:
    //   from	to	target	type
    //   3	11	172	java/lang/SecurityException
    //   15	22	172	java/lang/SecurityException
    //   25	84	172	java/lang/SecurityException
    //   84	90	172	java/lang/SecurityException }
  
  @ReactMethod
  public void getCurrentConnectivity(Promise paramPromise) {
    if (this.mNoNetworkPermission) {
      paramPromise.reject("E_MISSING_PERMISSION", "To use NetInfo on Android, add the following to your AndroidManifest.xml:\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />");
      return;
    } 
    paramPromise.resolve(createConnectivityEventMap());
  }
  
  public String getName() { return "NetInfo"; }
  
  public void initialize() { getReactApplicationContext().addLifecycleEventListener(this); }
  
  @ReactMethod
  public void isConnectionMetered(Promise paramPromise) {
    if (this.mNoNetworkPermission) {
      paramPromise.reject("E_MISSING_PERMISSION", "To use NetInfo on Android, add the following to your AndroidManifest.xml:\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />");
      return;
    } 
    paramPromise.resolve(Boolean.valueOf(a.a(this.mConnectivityManager)));
  }
  
  public void onHostDestroy() {}
  
  public void onHostPause() { unregisterReceiver(); }
  
  public void onHostResume() { registerReceiver(); }
}
