package com.facebook.react.modules.core;

import android.util.SparseArray;
import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.LifecycleEventListener;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.UiThreadUtil;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.c.a;
import com.facebook.react.c.b;
import com.facebook.react.common.h;
import com.facebook.react.devsupport.a.b;
import com.facebook.react.module.a.a;
import java.util.PriorityQueue;
import java.util.concurrent.atomic.AtomicBoolean;

@a(a = "Timing")
public final class Timing extends ReactContextBaseJavaModule implements LifecycleEventListener, b {
  private static final float FRAME_DURATION_MS = 16.666666F;
  
  private static final float IDLE_CALLBACK_FRAME_DEADLINE_MS = 1.0F;
  
  public static final String NAME = "Timing";
  
  private final AtomicBoolean isPaused = new AtomicBoolean(true);
  
  private final AtomicBoolean isRunningTasks = new AtomicBoolean(false);
  
  private a mCurrentIdleCallbackRunnable;
  
  private final b mDevSupportManager;
  
  private boolean mFrameCallbackPosted = false;
  
  private boolean mFrameIdleCallbackPosted = false;
  
  private final Object mIdleCallbackGuard = new Object();
  
  private final b mIdleFrameCallback = new b(this, null);
  
  private final e mReactChoreographer;
  
  private boolean mSendIdleEvents = false;
  
  private final d mTimerFrameCallback = new d(this, null);
  
  private final Object mTimerGuard = new Object();
  
  private final SparseArray<c> mTimerIdsToTimers;
  
  private final PriorityQueue<c> mTimers;
  
  public Timing(ReactApplicationContext paramReactApplicationContext, b paramb) {
    super(paramReactApplicationContext);
    this.mDevSupportManager = paramb;
    this.mTimers = new PriorityQueue(11, new Object(this));
    this.mTimerIdsToTimers = new SparseArray();
    this.mReactChoreographer = e.b();
  }
  
  private void clearChoreographerIdleCallback() {
    if (this.mFrameIdleCallbackPosted) {
      this.mReactChoreographer.b(e.a.e, this.mIdleFrameCallback);
      this.mFrameIdleCallbackPosted = false;
    } 
  }
  
  private void clearFrameCallback() {
    a a1 = a.a(getReactApplicationContext());
    if (this.mFrameCallbackPosted && this.isPaused.get() && !a1.a()) {
      this.mReactChoreographer.b(e.a.d, this.mTimerFrameCallback);
      this.mFrameCallbackPosted = false;
    } 
  }
  
  private void maybeIdleCallback() {
    if (this.isPaused.get() && !this.isRunningTasks.get())
      clearFrameCallback(); 
  }
  
  private void maybeSetChoreographerIdleCallback() {
    synchronized (this.mIdleCallbackGuard) {
      if (this.mSendIdleEvents)
        setChoreographerIdleCallback(); 
      return;
    } 
  }
  
  private void setChoreographerCallback() {
    if (!this.mFrameCallbackPosted) {
      this.mReactChoreographer.a(e.a.d, this.mTimerFrameCallback);
      this.mFrameCallbackPosted = true;
    } 
  }
  
  private void setChoreographerIdleCallback() {
    if (!this.mFrameIdleCallbackPosted) {
      this.mReactChoreographer.a(e.a.e, this.mIdleFrameCallback);
      this.mFrameIdleCallbackPosted = true;
    } 
  }
  
  @ReactMethod
  public void createTimer(int paramInt1, int paramInt2, double paramDouble, boolean paramBoolean) {
    long l1 = h.a();
    long l2 = (long)paramDouble;
    if (this.mDevSupportManager.d() && Math.abs(l2 - l1) > 60000L)
      ((JSTimers)getReactApplicationContext().getJSModule(JSTimers.class)).emitTimeDriftWarning("Debugger and device times have drifted by more than 60s. Please correct this by running adb shell \"date `date +%m%d%H%M%Y.%S`\" on your debugger machine."); 
    l1 = Math.max(0L, l2 - l1 + paramInt2);
    if (paramInt2 == 0 && !paramBoolean) {
      WritableArray writableArray = Arguments.createArray();
      writableArray.pushInt(paramInt1);
      ((JSTimers)getReactApplicationContext().getJSModule(JSTimers.class)).callTimers(writableArray);
      return;
    } 
    null = new c(paramInt1, h.b() / 1000000L + l1, paramInt2, paramBoolean, null);
    synchronized (this.mTimerGuard) {
      this.mTimers.add(null);
      this.mTimerIdsToTimers.put(paramInt1, null);
      return;
    } 
  }
  
  @ReactMethod
  public void deleteTimer(int paramInt) {
    synchronized (this.mTimerGuard) {
      c c = (c)this.mTimerIdsToTimers.get(paramInt);
      if (c == null)
        return; 
      this.mTimerIdsToTimers.remove(paramInt);
      this.mTimers.remove(c);
      return;
    } 
  }
  
  public String getName() { return "Timing"; }
  
  public void initialize() {
    getReactApplicationContext().addLifecycleEventListener(this);
    a.a(getReactApplicationContext()).a(this);
  }
  
  public void onCatalystInstanceDestroy() {
    clearFrameCallback();
    clearChoreographerIdleCallback();
    a.a(getReactApplicationContext()).b(this);
  }
  
  public void onHeadlessJsTaskFinish(int paramInt) {
    if (!a.a(getReactApplicationContext()).a()) {
      this.isRunningTasks.set(false);
      clearFrameCallback();
      maybeIdleCallback();
    } 
  }
  
  public void onHeadlessJsTaskStart(int paramInt) {
    if (!this.isRunningTasks.getAndSet(true)) {
      setChoreographerCallback();
      maybeSetChoreographerIdleCallback();
    } 
  }
  
  public void onHostDestroy() {
    clearFrameCallback();
    maybeIdleCallback();
  }
  
  public void onHostPause() {
    this.isPaused.set(true);
    clearFrameCallback();
    maybeIdleCallback();
  }
  
  public void onHostResume() {
    this.isPaused.set(false);
    setChoreographerCallback();
    maybeSetChoreographerIdleCallback();
  }
  
  @ReactMethod
  public void setSendIdleEvents(boolean paramBoolean) {
    synchronized (this.mIdleCallbackGuard) {
      this.mSendIdleEvents = paramBoolean;
      UiThreadUtil.runOnUiThread(new Object(this, paramBoolean));
      return;
    } 
  }
}
