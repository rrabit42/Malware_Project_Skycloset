package com.facebook.react.modules.blob;

import android.content.res.Resources;
import android.database.Cursor;
import android.net.Uri;
import android.webkit.MimeTypeMap;
import b.f;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.common.e;
import com.facebook.react.module.a.a;
import com.facebook.react.modules.network.NetworkingModule;
import com.facebook.react.modules.websocket.WebSocketModule;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

@a(a = "BlobModule")
public class BlobModule extends ReactContextBaseJavaModule {
  protected static final String NAME = "BlobModule";
  
  private final Map<String, byte[]> mBlobs = new HashMap();
  
  private final NetworkingModule.a mNetworkingRequestBodyHandler = new Object(this);
  
  private final NetworkingModule.b mNetworkingResponseHandler = new Object(this);
  
  private final NetworkingModule.c mNetworkingUriHandler = new Object(this);
  
  private final WebSocketModule.a mWebSocketContentHandler = new Object(this);
  
  public BlobModule(ReactApplicationContext paramReactApplicationContext) { super(paramReactApplicationContext); }
  
  private byte[] getBytesFromUri(Uri paramUri) {
    ByteArrayOutputStream byteArrayOutputStream;
    InputStream inputStream = getReactApplicationContext().getContentResolver().openInputStream(paramUri);
    if (inputStream != null) {
      byteArrayOutputStream = new ByteArrayOutputStream();
      byte[] arrayOfByte = new byte[1024];
      while (true) {
        int i = inputStream.read(arrayOfByte);
        if (i != -1) {
          byteArrayOutputStream.write(arrayOfByte, 0, i);
          continue;
        } 
        break;
      } 
      return byteArrayOutputStream.toByteArray();
    } 
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.append("File not found for ");
    stringBuilder.append(byteArrayOutputStream);
    throw new FileNotFoundException(stringBuilder.toString());
  }
  
  private long getLastModifiedFromUri(Uri paramUri) { return "file".equals(paramUri.getScheme()) ? (new File(paramUri.toString())).lastModified() : 0L; }
  
  private String getMimeTypeFromUri(Uri paramUri) {
    String str3 = getReactApplicationContext().getContentResolver().getType(paramUri);
    String str2 = str3;
    if (str3 == null) {
      String str = MimeTypeMap.getFileExtensionFromUrl(paramUri.getPath());
      str2 = str3;
      if (str != null)
        str2 = MimeTypeMap.getSingleton().getMimeTypeFromExtension(str); 
    } 
    String str1 = str2;
    if (str2 == null)
      str1 = ""; 
    return str1;
  }
  
  private String getNameFromUri(Uri paramUri) {
    if ("file".equals(paramUri.getScheme()))
      return paramUri.getLastPathSegment(); 
    cursor = getReactApplicationContext().getContentResolver().query(paramUri, new String[] { "_display_name" }, null, null, null);
    if (cursor != null)
      try {
        if (cursor.moveToFirst())
          return cursor.getString(0); 
      } finally {
        cursor.close();
      }  
    return paramUri.getLastPathSegment();
  }
  
  private WebSocketModule getWebSocketModule() { return (WebSocketModule)getReactApplicationContext().getNativeModule(WebSocketModule.class); }
  
  @ReactMethod
  public void addNetworkingHandler() {
    NetworkingModule networkingModule = (NetworkingModule)getReactApplicationContext().getNativeModule(NetworkingModule.class);
    networkingModule.addUriHandler(this.mNetworkingUriHandler);
    networkingModule.addRequestBodyHandler(this.mNetworkingRequestBodyHandler);
    networkingModule.addResponseHandler(this.mNetworkingResponseHandler);
  }
  
  @ReactMethod
  public void addWebSocketHandler(int paramInt) { getWebSocketModule().setContentHandler(paramInt, this.mWebSocketContentHandler); }
  
  @ReactMethod
  public void createFromParts(ReadableArray paramReadableArray, String paramString) { // Byte code:
    //   0: new java/util/ArrayList
    //   3: dup
    //   4: aload_1
    //   5: invokeinterface size : ()I
    //   10: invokespecial <init> : (I)V
    //   13: astore #7
    //   15: iconst_0
    //   16: istore #4
    //   18: iload #4
    //   20: istore #5
    //   22: iload #4
    //   24: aload_1
    //   25: invokeinterface size : ()I
    //   30: if_icmpge -> 260
    //   33: aload_1
    //   34: iload #4
    //   36: invokeinterface getMap : (I)Lcom/facebook/react/bridge/ReadableMap;
    //   41: astore #6
    //   43: aload #6
    //   45: ldc 'type'
    //   47: invokeinterface getString : (Ljava/lang/String;)Ljava/lang/String;
    //   52: astore #8
    //   54: aload #8
    //   56: invokevirtual hashCode : ()I
    //   59: istore_3
    //   60: iload_3
    //   61: ldc -891985903
    //   63: if_icmpeq -> 91
    //   66: iload_3
    //   67: ldc 3026845
    //   69: if_icmpeq -> 75
    //   72: goto -> 107
    //   75: aload #8
    //   77: ldc_w 'blob'
    //   80: invokevirtual equals : (Ljava/lang/Object;)Z
    //   83: ifeq -> 107
    //   86: iconst_0
    //   87: istore_3
    //   88: goto -> 109
    //   91: aload #8
    //   93: ldc_w 'string'
    //   96: invokevirtual equals : (Ljava/lang/Object;)Z
    //   99: ifeq -> 107
    //   102: iconst_1
    //   103: istore_3
    //   104: goto -> 109
    //   107: iconst_m1
    //   108: istore_3
    //   109: iload_3
    //   110: tableswitch default -> 132, 0 -> 205, 1 -> 174
    //   132: new java/lang/StringBuilder
    //   135: dup
    //   136: invokespecial <init> : ()V
    //   139: astore_1
    //   140: aload_1
    //   141: ldc_w 'Invalid type for blob: '
    //   144: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   147: pop
    //   148: aload_1
    //   149: aload #6
    //   151: ldc 'type'
    //   153: invokeinterface getString : (Ljava/lang/String;)Ljava/lang/String;
    //   158: invokevirtual append : (Ljava/lang/String;)Ljava/lang/StringBuilder;
    //   161: pop
    //   162: new java/lang/IllegalArgumentException
    //   165: dup
    //   166: aload_1
    //   167: invokevirtual toString : ()Ljava/lang/String;
    //   170: invokespecial <init> : (Ljava/lang/String;)V
    //   173: athrow
    //   174: aload #6
    //   176: ldc_w 'data'
    //   179: invokeinterface getString : (Ljava/lang/String;)Ljava/lang/String;
    //   184: ldc_w 'UTF-8'
    //   187: invokestatic forName : (Ljava/lang/String;)Ljava/nio/charset/Charset;
    //   190: invokevirtual getBytes : (Ljava/nio/charset/Charset;)[B
    //   193: astore #6
    //   195: iload #5
    //   197: aload #6
    //   199: arraylength
    //   200: iadd
    //   201: istore_3
    //   202: goto -> 239
    //   205: aload #6
    //   207: ldc_w 'data'
    //   210: invokeinterface getMap : (Ljava/lang/String;)Lcom/facebook/react/bridge/ReadableMap;
    //   215: astore #6
    //   217: iload #5
    //   219: aload #6
    //   221: ldc_w 'size'
    //   224: invokeinterface getInt : (Ljava/lang/String;)I
    //   229: iadd
    //   230: istore_3
    //   231: aload_0
    //   232: aload #6
    //   234: invokevirtual resolve : (Lcom/facebook/react/bridge/ReadableMap;)[B
    //   237: astore #6
    //   239: aload #7
    //   241: iload #4
    //   243: aload #6
    //   245: invokevirtual add : (ILjava/lang/Object;)V
    //   248: iload #4
    //   250: iconst_1
    //   251: iadd
    //   252: istore #4
    //   254: iload_3
    //   255: istore #5
    //   257: goto -> 22
    //   260: iload #5
    //   262: invokestatic allocate : (I)Ljava/nio/ByteBuffer;
    //   265: astore_1
    //   266: aload #7
    //   268: invokevirtual iterator : ()Ljava/util/Iterator;
    //   271: astore #6
    //   273: aload #6
    //   275: invokeinterface hasNext : ()Z
    //   280: ifeq -> 301
    //   283: aload_1
    //   284: aload #6
    //   286: invokeinterface next : ()Ljava/lang/Object;
    //   291: checkcast [B
    //   294: invokevirtual put : ([B)Ljava/nio/ByteBuffer;
    //   297: pop
    //   298: goto -> 273
    //   301: aload_0
    //   302: aload_1
    //   303: invokevirtual array : ()[B
    //   306: aload_2
    //   307: invokevirtual store : ([BLjava/lang/String;)V
    //   310: return }
  
  public Map<String, Object> getConstants() {
    Resources resources = getReactApplicationContext().getResources();
    int i = resources.getIdentifier("blob_provider_authority", "string", getReactApplicationContext().getPackageName());
    return (i == 0) ? null : e.a("BLOB_URI_SCHEME", "content", "BLOB_URI_HOST", resources.getString(i));
  }
  
  public String getName() { return "BlobModule"; }
  
  @ReactMethod
  public void release(String paramString) { remove(paramString); }
  
  public void remove(String paramString) { this.mBlobs.remove(paramString); }
  
  @ReactMethod
  public void removeWebSocketHandler(int paramInt) { getWebSocketModule().setContentHandler(paramInt, null); }
  
  public byte[] resolve(Uri paramUri) {
    byte b2;
    byte b1;
    String str2 = paramUri.getLastPathSegment();
    String str3 = paramUri.getQueryParameter("offset");
    if (str3 != null) {
      b1 = Integer.parseInt(str3, 10);
    } else {
      b1 = 0;
    } 
    String str1 = paramUri.getQueryParameter("size");
    if (str1 != null) {
      b2 = Integer.parseInt(str1, 10);
    } else {
      b2 = -1;
    } 
    return resolve(str2, b1, b2);
  }
  
  public byte[] resolve(ReadableMap paramReadableMap) { return resolve(paramReadableMap.getString("blobId"), paramReadableMap.getInt("offset"), paramReadableMap.getInt("size")); }
  
  public byte[] resolve(String paramString, int paramInt1, int paramInt2) {
    byte[] arrayOfByte = (byte[])this.mBlobs.get(paramString);
    if (arrayOfByte == null)
      return null; 
    int i = paramInt2;
    if (paramInt2 == -1)
      i = arrayOfByte.length - paramInt1; 
    if (paramInt1 <= 0) {
      byte[] arrayOfByte1 = arrayOfByte;
      return (i != arrayOfByte.length) ? Arrays.copyOfRange(arrayOfByte, paramInt1, i + paramInt1) : arrayOfByte1;
    } 
    return Arrays.copyOfRange(arrayOfByte, paramInt1, i + paramInt1);
  }
  
  @ReactMethod
  public void sendOverSocket(ReadableMap paramReadableMap, int paramInt) {
    byte[] arrayOfByte = resolve(paramReadableMap.getString("blobId"), paramReadableMap.getInt("offset"), paramReadableMap.getInt("size"));
    if (arrayOfByte != null) {
      getWebSocketModule().sendBinary(f.a(arrayOfByte), paramInt);
      return;
    } 
    getWebSocketModule().sendBinary((f)null, paramInt);
  }
  
  public String store(byte[] paramArrayOfByte) {
    String str = UUID.randomUUID().toString();
    store(paramArrayOfByte, str);
    return str;
  }
  
  public void store(byte[] paramArrayOfByte, String paramString) { this.mBlobs.put(paramString, paramArrayOfByte); }
}
