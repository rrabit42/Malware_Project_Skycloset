package com.facebook.react.modules.camera;

import android.annotation.SuppressLint;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.media.ExifInterface;
import android.net.Uri;
import android.os.AsyncTask;
import android.text.TextUtils;
import com.facebook.common.e.a;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.JSApplicationIllegalArgumentException;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.module.a.a;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

@a(a = "ImageEditingManager")
public class ImageEditingManager extends ReactContextBaseJavaModule {
  private static final int COMPRESS_QUALITY = 90;
  
  @SuppressLint({"InlinedApi"})
  private static final String[] EXIF_ATTRIBUTES;
  
  private static final List<String> LOCAL_URI_PREFIXES = Arrays.asList(new String[] { "file://", "content://" });
  
  protected static final String NAME = "ImageEditingManager";
  
  private static final String TEMP_FILE_PREFIX = "ReactNative_cropped_image_";
  
  static  {
    EXIF_ATTRIBUTES = new String[] { 
        "FNumber", "DateTime", "DateTimeDigitized", "ExposureTime", "Flash", "FocalLength", "GPSAltitude", "GPSAltitudeRef", "GPSDateStamp", "GPSLatitude", 
        "GPSLatitudeRef", "GPSLongitude", "GPSLongitudeRef", "GPSProcessingMethod", "GPSTimeStamp", "ImageLength", "ImageWidth", "ISOSpeedRatings", "Make", "Model", 
        "Orientation", "SubSecTime", "SubSecTimeDigitized", "SubSecTimeOriginal", "WhiteBalance" };
  }
  
  public ImageEditingManager(ReactApplicationContext paramReactApplicationContext) {
    super(paramReactApplicationContext);
    (new a(getReactApplicationContext(), null)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, new Void[0]);
  }
  
  private static void copyExif(Context paramContext, Uri paramUri, File paramFile) {
    StringBuilder stringBuilder = getFileFromUri(paramContext, paramUri);
    if (stringBuilder == null) {
      stringBuilder = new StringBuilder();
      stringBuilder.append("Couldn't get real path for uri: ");
      stringBuilder.append(paramUri);
      a.c("ReactNative", stringBuilder.toString());
      return;
    } 
    ExifInterface exifInterface1 = new ExifInterface(stringBuilder.getAbsolutePath());
    ExifInterface exifInterface2 = new ExifInterface(paramFile.getAbsolutePath());
    for (String str1 : EXIF_ATTRIBUTES) {
      String str2 = exifInterface1.getAttribute(str1);
      if (str2 != null)
        exifInterface2.setAttribute(str1, str2); 
    } 
    exifInterface2.saveAttributes();
  }
  
  private static File createTempFile(Context paramContext, String paramString) {
    File file2 = paramContext.getExternalCacheDir();
    File file1 = paramContext.getCacheDir();
    if (file2 != null || file1 != null) {
      if (file2 != null)
        if (file1 == null) {
          file1 = file2;
        } else if (file2.getFreeSpace() > file1.getFreeSpace()) {
          file1 = file2;
        }  
      return File.createTempFile("ReactNative_cropped_image_", getFileExtensionForType(paramString), file1);
    } 
    throw new IOException("No cache directory available");
  }
  
  private static Bitmap.CompressFormat getCompressFormatForType(String paramString) { return "image/png".equals(paramString) ? Bitmap.CompressFormat.PNG : ("image/webp".equals(paramString) ? Bitmap.CompressFormat.WEBP : Bitmap.CompressFormat.JPEG); }
  
  private static int getDecodeSampleSize(int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    int i = 1;
    int j = 1;
    if (paramInt2 > paramInt3 || paramInt1 > paramInt4) {
      paramInt2 /= 2;
      int k = paramInt1 / 2;
      paramInt1 = j;
      while (true) {
        i = paramInt1;
        if (k / paramInt1 >= paramInt3) {
          i = paramInt1;
          if (paramInt2 / paramInt1 >= paramInt4) {
            paramInt1 *= 2;
            continue;
          } 
        } 
        break;
      } 
    } 
    return i;
  }
  
  private static String getFileExtensionForType(String paramString) { return "image/png".equals(paramString) ? ".png" : ("image/webp".equals(paramString) ? ".webp" : ".jpg"); }
  
  private static File getFileFromUri(Context paramContext, Uri paramUri) {
    if (paramUri.getScheme().equals("file"))
      return new File(paramUri.getPath()); 
    if (paramUri.getScheme().equals("content")) {
      cursor = paramContext.getContentResolver().query(paramUri, new String[] { "_data" }, null, null, null);
      if (cursor != null)
        try {
          if (cursor.moveToFirst()) {
            String str = cursor.getString(0);
            if (!TextUtils.isEmpty(str))
              return new File(str); 
          } 
        } finally {
          cursor.close();
        }  
    } 
    return null;
  }
  
  private static boolean isLocalUri(String paramString) {
    Iterator iterator = LOCAL_URI_PREFIXES.iterator();
    while (iterator.hasNext()) {
      if (paramString.startsWith((String)iterator.next()))
        return true; 
    } 
    return false;
  }
  
  private static void writeCompressedBitmapToFile(Bitmap paramBitmap, String paramString, File paramFile) {
    fileOutputStream = new FileOutputStream(paramFile);
    try {
      paramBitmap.compress(getCompressFormatForType(paramString), 90, fileOutputStream);
      return;
    } finally {
      fileOutputStream.close();
    } 
  }
  
  @ReactMethod
  public void cropImage(String paramString, ReadableMap paramReadableMap, Callback paramCallback1, Callback paramCallback2) {
    Object object;
    boolean bool = paramReadableMap.hasKey("offset");
    ReadableMap readableMap = null;
    if (bool) {
      object = paramReadableMap.getMap("offset");
    } else {
      object = null;
    } 
    if (paramReadableMap.hasKey("size"))
      readableMap = paramReadableMap.getMap("size"); 
    if (object != null && readableMap != null && object.hasKey("x") && object.hasKey("y") && readableMap.hasKey("width") && readableMap.hasKey("height")) {
      if (paramString != null && !paramString.isEmpty()) {
        b b = new b(getReactApplicationContext(), paramString, (int)object.getDouble("x"), (int)object.getDouble("y"), (int)readableMap.getDouble("width"), (int)readableMap.getDouble("height"), paramCallback1, paramCallback2, null);
        if (paramReadableMap.hasKey("displaySize")) {
          paramReadableMap = paramReadableMap.getMap("displaySize");
          b.a((int)paramReadableMap.getDouble("width"), (int)paramReadableMap.getDouble("height"));
        } 
        b.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, new Void[0]);
        return;
      } 
      throw new JSApplicationIllegalArgumentException("Please specify a URI");
    } 
    throw new JSApplicationIllegalArgumentException("Please specify offset and size");
  }
  
  public Map<String, Object> getConstants() { return Collections.emptyMap(); }
  
  public String getName() { return "ImageEditingManager"; }
  
  public void onCatalystInstanceDestroy() { (new a(getReactApplicationContext(), null)).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, new Void[0]); }
}
