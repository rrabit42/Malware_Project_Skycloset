package com.facebook.react.fabric;

import android.annotation.SuppressLint;
import android.os.SystemClock;
import com.facebook.common.e.a;
import com.facebook.i.a.a;
import com.facebook.j.a.a;
import com.facebook.react.bridge.LifecycleEventListener;
import com.facebook.react.bridge.NativeMap;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableNativeMap;
import com.facebook.react.bridge.UIManager;
import com.facebook.react.bridge.UiThreadUtil;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.fabric.jsi.Binding;
import com.facebook.react.fabric.jsi.EventBeatManager;
import com.facebook.react.fabric.jsi.EventEmitterWrapper;
import com.facebook.react.fabric.jsi.a;
import com.facebook.react.fabric.mounting.b;
import com.facebook.react.fabric.mounting.c;
import com.facebook.react.fabric.mounting.mountitems.BatchMountItem;
import com.facebook.react.fabric.mounting.mountitems.a;
import com.facebook.react.fabric.mounting.mountitems.b;
import com.facebook.react.fabric.mounting.mountitems.c;
import com.facebook.react.fabric.mounting.mountitems.d;
import com.facebook.react.fabric.mounting.mountitems.e;
import com.facebook.react.fabric.mounting.mountitems.f;
import com.facebook.react.fabric.mounting.mountitems.g;
import com.facebook.react.fabric.mounting.mountitems.h;
import com.facebook.react.fabric.mounting.mountitems.i;
import com.facebook.react.fabric.mounting.mountitems.j;
import com.facebook.react.fabric.mounting.mountitems.k;
import com.facebook.react.modules.core.e;
import com.facebook.react.uimanager.af;
import com.facebook.react.uimanager.as;
import com.facebook.react.uimanager.common.a;
import com.facebook.react.uimanager.events.d;
import com.facebook.react.uimanager.v;
import com.facebook.systrace.a;
import com.facebook.yoga.YogaMeasureMode;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@SuppressLint({"MissingNativeLoadLibrary"})
public class a implements LifecycleEventListener, UIManager {
  private static final String a = "a";
  
  private static final Map<String, String> b = new HashMap();
  
  private Binding c;
  
  private final ReactApplicationContext d;
  
  private final c e;
  
  private final d f;
  
  private final ConcurrentHashMap<Integer, af> g;
  
  private final EventBeatManager h;
  
  private final Object i;
  
  private final Object j;
  
  private List<e> k;
  
  private List<e> l;
  
  private final a m;
  
  private boolean n;
  
  private long o;
  
  private long p;
  
  private long q;
  
  private long r;
  
  private long s;
  
  private long t;
  
  private long u;
  
  static  {
    a.a();
    b.put("View", "RCTView");
    b.put("Image", "RCTImageView");
    b.put("ScrollView", "RCTScrollView");
    b.put("ReactPerformanceLoggerFlag", "ReactPerformanceLoggerFlag");
    b.put("Paragraph", "RCTText");
    b.put("Text", "RCText");
    b.put("RawText", "RCTRawText");
    b.put("ActivityIndicatorView", "AndroidProgressBar");
    b.put("ShimmeringView", "RKShimmeringView");
    b.put("TemplateView", "RCTTemplateView");
  }
  
  private void a() {
    if (!this.n) {
      a.c("ReactNative", "Not flushing pending UI operations because of previously thrown Exception");
      return;
    } 
    try {
      synchronized (this.j) {
        List list = this.l;
        this.l = new ArrayList();
        this.o = SystemClock.uptimeMillis();
        synchronized (this.i) {
          null = this.k;
          this.k = new ArrayList();
          long l1 = SystemClock.uptimeMillis();
          null = new StringBuilder();
          null.append("FabricUIManager::premountViews (");
          null.append(list.size());
          null.append(" batches)");
          a.a(0L, null.toString());
          Iterator iterator = list.iterator();
          while (iterator.hasNext())
            ((e)iterator.next()).a(this.e); 
          this.q = SystemClock.uptimeMillis() - l1;
          a.b(0L);
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.append("FabricUIManager::mountViews (");
          stringBuilder.append(null.size());
          stringBuilder.append(" batches)");
          a.a(0L, stringBuilder.toString());
          l1 = SystemClock.uptimeMillis();
          null = null.iterator();
          while (null.hasNext())
            ((e)null.next()).a(this.e); 
          this.p = SystemClock.uptimeMillis() - l1;
          a.b(0L);
          return;
        } 
      } 
    } catch (Exception exception) {
      a.c("ReactNative", "Exception thrown when executing UIFrameGuarded", exception);
      this.n = false;
      throw exception;
    } 
  }
  
  @a
  private e createBatchMountItem(e[] paramArrayOfe, int paramInt) { return new BatchMountItem(paramArrayOfe, paramInt); }
  
  @a
  private e createMountItem(String paramString, int paramInt1, int paramInt2, boolean paramBoolean) {
    StringBuilder stringBuilder1;
    String str = (String)b.get(paramString);
    if (str != null) {
      af af = (af)this.g.get(Integer.valueOf(paramInt1));
      if (af != null)
        return new a(af, str, paramInt2, paramBoolean); 
      stringBuilder1 = new StringBuilder();
      stringBuilder1.append("Unable to find ReactContext for root: ");
      stringBuilder1.append(paramInt1);
      throw new IllegalArgumentException(stringBuilder1.toString());
    } 
    StringBuilder stringBuilder2 = new StringBuilder();
    stringBuilder2.append("Unable to find component with name ");
    stringBuilder2.append(stringBuilder1);
    throw new IllegalArgumentException(stringBuilder2.toString());
  }
  
  @a
  private e deleteMountItem(int paramInt) { return new b(paramInt); }
  
  @a
  private e insertMountItem(int paramInt1, int paramInt2, int paramInt3) { return new d(paramInt1, paramInt2, paramInt3); }
  
  @a
  private long measure(String paramString, ReadableNativeMap paramReadableNativeMap1, ReadableNativeMap paramReadableNativeMap2, int paramInt1, int paramInt2, int paramInt3, int paramInt4) {
    c c1 = this.e;
    ReactApplicationContext reactApplicationContext = this.d;
    float f2 = paramInt1;
    float f3 = paramInt2;
    float f1 = b.a(f2, f3);
    YogaMeasureMode yogaMeasureMode = b.b(f2, f3);
    f2 = paramInt3;
    f3 = paramInt4;
    return c1.a(reactApplicationContext, paramString, paramReadableNativeMap1, paramReadableNativeMap2, f1, yogaMeasureMode, b.a(f2, f3), b.b(f2, f3));
  }
  
  @a
  private void preallocateView(int paramInt, String paramString) {
    if (UiThreadUtil.isOnUiThread())
      return; 
    synchronized (this.j) {
      af af = (af)a.a(this.g.get(Integer.valueOf(paramInt)));
      paramString = (String)b.get(paramString);
      a.a(paramString);
      this.l.add(new f(af, paramInt, paramString));
      return;
    } 
  }
  
  @a
  private e removeMountItem(int paramInt1, int paramInt2, int paramInt3) { return new g(paramInt1, paramInt2, paramInt3); }
  
  @a
  private void scheduleMountItems(e parame, long paramLong1, long paramLong2, long paramLong3) {
    this.s = paramLong1;
    this.t = paramLong2;
    this.u = SystemClock.uptimeMillis() - paramLong3;
    this.r = SystemClock.uptimeMillis();
    synchronized (this.i) {
      this.k.add(parame);
      if (UiThreadUtil.isOnUiThread())
        a(); 
      return;
    } 
  }
  
  @a
  private e updateEventEmitterMountItem(int paramInt, Object paramObject) { return new h(paramInt, (EventEmitterWrapper)paramObject); }
  
  @a
  private e updateLayoutMountItem(int paramInt1, int paramInt2, int paramInt3, int paramInt4, int paramInt5) { return new i(paramInt1, paramInt2, paramInt3, paramInt4, paramInt5); }
  
  @a
  private e updateLocalDataMountItem(int paramInt, ReadableNativeMap paramReadableNativeMap) { return new j(paramInt, paramReadableNativeMap); }
  
  @a
  private e updatePropsMountItem(int paramInt, ReadableNativeMap paramReadableNativeMap) { return new k(paramInt, paramReadableNativeMap); }
  
  public void a(int paramInt, String paramString, WritableMap paramWritableMap) {
    String str;
    StringBuilder stringBuilder = this.e.c(paramInt);
    if (stringBuilder == null) {
      str = a;
      stringBuilder = new StringBuilder();
      stringBuilder.append("Unable to invoke event: ");
      stringBuilder.append(paramString);
      stringBuilder.append(" for reactTag: ");
      stringBuilder.append(paramInt);
      a.a(str, stringBuilder.toString());
      return;
    } 
    stringBuilder.a(paramString, str);
  }
  
  public <T extends com.facebook.react.uimanager.common.SizeMonitoringFrameLayout & a> int addRootView(T paramT, WritableMap paramWritableMap, String paramString) {
    int i1 = v.a();
    af af = new af(this.d, paramT.getContext());
    this.e.a(i1, paramT);
    this.g.put(Integer.valueOf(i1), af);
    this.c.startSurface(i1, (NativeMap)paramWritableMap);
    paramT = (T)(a)paramT;
    updateRootLayoutSpecs(i1, paramT.getWidthMeasureSpec(), paramT.getHeightMeasureSpec());
    if (paramString != null)
      this.c.renderTemplateToSurface(i1, paramString); 
    return i1;
  }
  
  public void clearJSResponder() {}
  
  public void dispatchCommand(int paramInt1, int paramInt2, ReadableArray paramReadableArray) {
    synchronized (this.i) {
      this.k.add(new c(paramInt1, paramInt2, paramReadableArray));
      return;
    } 
  }
  
  public Map<String, Long> getPerformanceCounters() {
    HashMap hashMap = new HashMap();
    hashMap.put("CommitStartTime", Long.valueOf(this.s));
    hashMap.put("LayoutTime", Long.valueOf(this.t));
    hashMap.put("DispatchViewUpdatesTime", Long.valueOf(this.r));
    hashMap.put("RunStartTime", Long.valueOf(this.o));
    hashMap.put("BatchedExecutionTime", Long.valueOf(this.p));
    hashMap.put("NonBatchedExecutionTime", Long.valueOf(this.q));
    hashMap.put("FinishFabricTransactionTime", Long.valueOf(this.u));
    return hashMap;
  }
  
  public void initialize() {
    this.f.a(2, new FabricEventEmitter(this));
    this.f.a(this.h);
  }
  
  public void onCatalystInstanceDestroy() {
    this.f.b(this.h);
    this.f.a(2);
    this.c.a();
    as.a();
  }
  
  public void onHostDestroy() {}
  
  public void onHostPause() { e.b().b(e.a.b, this.m); }
  
  public void onHostResume() { e.b().a(e.a.b, this.m); }
  
  @a
  public void onRequestEventBeat() { this.f.a(); }
  
  public void profileNextBatch() {}
  
  public void removeRootView(int paramInt) {
    this.e.a(paramInt);
    this.g.remove(Integer.valueOf(paramInt));
  }
  
  public void setJSResponder(int paramInt, boolean paramBoolean) {}
  
  public void updateRootLayoutSpecs(int paramInt1, int paramInt2, int paramInt3) {
    ReactApplicationContext reactApplicationContext = this.d;
    reactApplicationContext.runOnJSQueueThread(new Object(this, reactApplicationContext, paramInt1, paramInt2, paramInt3));
  }
}
