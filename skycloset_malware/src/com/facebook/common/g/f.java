package com.facebook.common.g;

import com.facebook.common.d.i;
import com.facebook.common.e.a;
import com.facebook.common.h.c;
import java.io.IOException;
import java.io.InputStream;

public class f extends InputStream {
  private final InputStream a;
  
  private final byte[] b;
  
  private final c<byte[]> c;
  
  private int d;
  
  private int e;
  
  private boolean f;
  
  public f(InputStream paramInputStream, byte[] paramArrayOfByte, c<byte[]> paramc) {
    this.a = (InputStream)i.a(paramInputStream);
    this.b = (byte[])i.a(paramArrayOfByte);
    this.c = (c)i.a(paramc);
    this.d = 0;
    this.e = 0;
    this.f = false;
  }
  
  private boolean a() {
    if (this.e < this.d)
      return true; 
    int i = this.a.read(this.b);
    if (i <= 0)
      return false; 
    this.d = i;
    this.e = 0;
    return true;
  }
  
  private void b() {
    if (!this.f)
      return; 
    throw new IOException("stream already closed");
  }
  
  public int available() {
    boolean bool;
    if (this.e <= this.d) {
      bool = true;
    } else {
      bool = false;
    } 
    i.b(bool);
    b();
    return this.d - this.e + this.a.available();
  }
  
  public void close() {
    if (!this.f) {
      this.f = true;
      this.c.a(this.b);
      super.close();
    } 
  }
  
  protected void finalize() {
    if (!this.f) {
      a.d("PooledByteInputStream", "Finalized without closing");
      close();
    } 
    super.finalize();
  }
  
  public int read() {
    boolean bool;
    if (this.e <= this.d) {
      bool = true;
    } else {
      bool = false;
    } 
    i.b(bool);
    b();
    if (!a())
      return -1; 
    byte[] arrayOfByte = this.b;
    int i = this.e;
    this.e = i + 1;
    return arrayOfByte[i] & 0xFF;
  }
  
  public int read(byte[] paramArrayOfByte, int paramInt1, int paramInt2) {
    boolean bool;
    if (this.e <= this.d) {
      bool = true;
    } else {
      bool = false;
    } 
    i.b(bool);
    b();
    if (!a())
      return -1; 
    paramInt2 = Math.min(this.d - this.e, paramInt2);
    System.arraycopy(this.b, this.e, paramArrayOfByte, paramInt1, paramInt2);
    this.e += paramInt2;
    return paramInt2;
  }
  
  public long skip(long paramLong) {
    boolean bool;
    if (this.e <= this.d) {
      bool = true;
    } else {
      bool = false;
    } 
    i.b(bool);
    b();
    int i = this.d;
    int j = this.e;
    long l = (i - j);
    if (l >= paramLong) {
      this.e = (int)(j + paramLong);
      return paramLong;
    } 
    this.e = i;
    return l + this.a.skip(paramLong - l);
  }
}
