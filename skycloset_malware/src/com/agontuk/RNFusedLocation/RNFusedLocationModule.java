package com.agontuk.RNFusedLocation;

import android.app.Activity;
import android.content.IntentSender;
import android.util.Log;
import com.facebook.react.bridge.ActivityEventListener;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import com.google.android.gms.c.d;
import com.google.android.gms.common.api.b;
import com.google.android.gms.common.api.i;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.b;
import com.google.android.gms.location.d;
import com.google.android.gms.location.f;
import com.google.android.gms.location.g;
import com.google.android.gms.location.h;
import com.google.android.gms.location.l;

public class RNFusedLocationModule extends ReactContextBaseJavaModule {
  private static final int DEFAULT_ACCURACY = 102;
  
  private static final float DEFAULT_DISTANCE_FILTER = 100.0F;
  
  private static final long DEFAULT_FASTEST_INTERVAL = 5000L;
  
  private static final long DEFAULT_INTERVAL = 10000L;
  
  private static final int REQUEST_SETTINGS_CONTINUOUS_UPDATE = 11404;
  
  private static final int REQUEST_SETTINGS_SINGLE_UPDATE = 11403;
  
  public static final String TAG = "RNFusedLocation";
  
  private final ActivityEventListener mActivityEventListener = new Object(this);
  
  private float mDistanceFilter = 100.0F;
  
  private Callback mErrorCallback;
  
  private long mFastestInterval = 5000L;
  
  private b mFusedProviderClient;
  
  private d mLocationCallback;
  
  private int mLocationPriority = 102;
  
  private LocationRequest mLocationRequest;
  
  private double mMaximumAge = Double.POSITIVE_INFINITY;
  
  private l mSettingsClient;
  
  private boolean mShowLocationDialog = true;
  
  private Callback mSuccessCallback;
  
  private long mTimeout = Float.MAX_VALUE;
  
  private long mUpdateInterval = 10000L;
  
  public RNFusedLocationModule(ReactApplicationContext paramReactApplicationContext) {
    super(paramReactApplicationContext);
    this.mFusedProviderClient = f.b(paramReactApplicationContext);
    this.mSettingsClient = f.a(paramReactApplicationContext);
    paramReactApplicationContext.addActivityEventListener(this.mActivityEventListener);
    Log.i("RNFusedLocation", "RNFusedLocation initialized");
  }
  
  private g buildLocationSettingsRequest() {
    this.mLocationRequest = new LocationRequest();
    this.mLocationRequest.a(this.mLocationPriority).a(this.mUpdateInterval).b(this.mFastestInterval).a(this.mDistanceFilter);
    g.a a = new g.a();
    a.a(this.mLocationRequest);
    return a.a();
  }
  
  private void clearCallbacks() {
    this.mSuccessCallback = null;
    this.mErrorCallback = null;
  }
  
  private ReactApplicationContext getContext() { return getReactApplicationContext(); }
  
  private void getLocationUpdates() {
    if (this.mFusedProviderClient != null && this.mLocationRequest != null) {
      this.mLocationCallback = new Object(this);
      this.mFusedProviderClient.a(this.mLocationRequest, this.mLocationCallback, null);
    } 
  }
  
  private void getUserLocation() {
    b b1 = this.mFusedProviderClient;
    if (b1 != null)
      b1.e().a(new Object(this)); 
  }
  
  private void invokeError(int paramInt, String paramString, boolean paramBoolean) {
    if (!paramBoolean) {
      ((DeviceEventManagerModule.RCTDeviceEventEmitter)getContext().getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)).emit("geolocationError", b.a(paramInt, paramString));
      return;
    } 
    try {
      if (this.mErrorCallback != null)
        this.mErrorCallback.invoke(new Object[] { b.a(paramInt, paramString) }); 
      clearCallbacks();
      return;
    } catch (RuntimeException paramString) {
      Log.w("RNFusedLocation", paramString.getMessage());
      return;
    } 
  }
  
  private void invokeSuccess(WritableMap paramWritableMap, boolean paramBoolean) {
    if (!paramBoolean) {
      ((DeviceEventManagerModule.RCTDeviceEventEmitter)getContext().getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)).emit("geolocationDidChange", paramWritableMap);
      return;
    } 
    try {
      if (this.mSuccessCallback != null)
        this.mSuccessCallback.invoke(new Object[] { paramWritableMap }); 
      clearCallbacks();
      return;
    } catch (RuntimeException paramWritableMap) {
      Log.w("RNFusedLocation", paramWritableMap.getMessage());
      return;
    } 
  }
  
  private void onLocationSettingsResponse(d<h> paramd, boolean paramBoolean) {
    char c;
    try {
      str = (h)paramd.a(b.class);
      if (paramBoolean) {
        getUserLocation();
        return;
      } 
      getLocationUpdates();
      return;
    } catch (b paramd) {
      if (paramd.a() != 6 || !this.mShowLocationDialog) {
        c = a.e.a();
        str = "Location settings are not satisfied.";
      } else {
        Activity activity;
        try {
          i i = (i)str;
          activity = getCurrentActivity();
          if (activity == null) {
            invokeError(a.f.a(), "Tried to open location dialog while not attached to an Activity", paramBoolean);
            return;
          } 
        } catch (android.content.IntentSender.SendIntentException|ClassCastException str) {
          c = a.f.a();
          str = "Internal error occurred";
          invokeError(c, str, paramBoolean);
          return;
        } 
        if (paramBoolean) {
          c = 'ⲋ';
        } else {
          c = 'Ⲍ';
        } 
        str.a(activity, c);
        return;
      } 
    } 
    invokeError(c, str, paramBoolean);
  }
  
  @ReactMethod
  public void getCurrentPosition(ReadableMap paramReadableMap, Callback paramCallback1, Callback paramCallback2) {
    byte b1;
    g g;
    ReactApplicationContext reactApplicationContext = getContext();
    this.mSuccessCallback = paramCallback1;
    this.mErrorCallback = paramCallback2;
    boolean bool2 = b.a(reactApplicationContext);
    boolean bool1 = true;
    if (!bool2) {
      b1 = a.a.a();
      g = "Location permission not granted.";
    } else if (!b.b(reactApplicationContext)) {
      b1 = a.d.a();
      g = "Google play service is not available.";
    } else {
      long l2;
      float f;
      double d1;
      if (g.hasKey("enableHighAccuracy") && g.getBoolean("enableHighAccuracy")) {
        b1 = 1;
      } else {
        b1 = 0;
      } 
      if (b1) {
        b1 = 100;
      } else {
        b1 = 102;
      } 
      this.mLocationPriority = b1;
      if (g.hasKey("timeout")) {
        l2 = (long)g.getDouble("timeout");
      } else {
        l2 = Float.MAX_VALUE;
      } 
      this.mTimeout = l2;
      if (g.hasKey("maximumAge")) {
        d1 = g.getDouble("maximumAge");
      } else {
        d1 = Double.POSITIVE_INFINITY;
      } 
      this.mMaximumAge = d1;
      if (g.hasKey("distanceFilter")) {
        f = (float)g.getDouble("distanceFilter");
      } else {
        f = 0.0F;
      } 
      this.mDistanceFilter = f;
      if (g.hasKey("showLocationDialog"))
        bool1 = g.getBoolean("showLocationDialog"); 
      this.mShowLocationDialog = bool1;
      g = buildLocationSettingsRequest();
      l l1 = this.mSettingsClient;
      if (l1 != null)
        l1.a(g).a(new Object(this)); 
      return;
    } 
    invokeError(b1, g, true);
  }
  
  public String getName() { return "RNFusedLocation"; }
  
  @ReactMethod
  public void startObserving(ReadableMap paramReadableMap) {
    byte b1;
    g g;
    ReactApplicationContext reactApplicationContext = getContext();
    boolean bool = b.a(reactApplicationContext);
    byte b2 = 0;
    if (!bool) {
      b1 = a.a.a();
      g = "Location permission not granted.";
    } else if (!b.b(reactApplicationContext)) {
      b1 = a.d.a();
      g = "Google play service is not available.";
    } else {
      float f;
      boolean bool1 = g.hasKey("enableHighAccuracy");
      bool = true;
      b1 = b2;
      if (bool1) {
        b1 = b2;
        if (g.getBoolean("enableHighAccuracy"))
          b1 = 1; 
      } 
      if (b1 != 0) {
        b1 = 100;
      } else {
        b1 = 102;
      } 
      this.mLocationPriority = b1;
      if (g.hasKey("distanceFilter")) {
        f = (float)g.getDouble("distanceFilter");
      } else {
        f = 100.0F;
      } 
      this.mDistanceFilter = f;
      bool1 = g.hasKey("interval");
      long l2 = 10000L;
      if (bool1) {
        l1 = (long)g.getDouble("interval");
      } else {
        l1 = 10000L;
      } 
      this.mUpdateInterval = l1;
      long l1 = l2;
      if (g.hasKey("fastestInterval"))
        l1 = (long)g.getDouble("fastestInterval"); 
      this.mFastestInterval = l1;
      if (g.hasKey("showLocationDialog"))
        bool = g.getBoolean("showLocationDialog"); 
      this.mShowLocationDialog = bool;
      g = buildLocationSettingsRequest();
      l l3 = this.mSettingsClient;
      if (l3 != null)
        l3.a(g).a(new Object(this)); 
      return;
    } 
    invokeError(b1, g, false);
  }
  
  @ReactMethod
  public void stopObserving() {
    b b1 = this.mFusedProviderClient;
    if (b1 != null) {
      d d1 = this.mLocationCallback;
      if (d1 != null) {
        b1.a(d1);
        this.mLocationCallback = null;
      } 
    } 
  }
}
