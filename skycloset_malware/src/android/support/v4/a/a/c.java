package android.support.v4.a.a;

import android.content.res.Resources;
import android.content.res.TypedArray;
import android.os.Build;
import android.support.a.a;
import android.support.v4.d.a;
import android.util.Base64;
import android.util.TypedValue;
import android.util.Xml;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import org.xmlpull.v1.XmlPullParser;
import org.xmlpull.v1.XmlPullParserException;

public class c {
  private static int a(TypedArray paramTypedArray, int paramInt) {
    if (Build.VERSION.SDK_INT >= 21)
      return paramTypedArray.getType(paramInt); 
    TypedValue typedValue = new TypedValue();
    paramTypedArray.getValue(paramInt, typedValue);
    return typedValue.type;
  }
  
  public static a a(XmlPullParser paramXmlPullParser, Resources paramResources) {
    int i;
    while (true) {
      i = paramXmlPullParser.next();
      if (i != 2 && i != 1)
        continue; 
      break;
    } 
    if (i == 2)
      return b(paramXmlPullParser, paramResources); 
    throw new XmlPullParserException("No start tag found");
  }
  
  public static List<List<byte[]>> a(Resources paramResources, int paramInt) {
    if (paramInt == 0)
      return Collections.emptyList(); 
    typedArray = paramResources.obtainTypedArray(paramInt);
    try {
      if (typedArray.length() == 0)
        return Collections.emptyList(); 
      arrayList = new ArrayList();
      if (a(typedArray, 0) == 1)
        for (paramInt = 0;; paramInt++) {
          if (paramInt < typedArray.length()) {
            int i = typedArray.getResourceId(paramInt, 0);
            if (i != 0)
              arrayList.add(a(null.getStringArray(i))); 
          } else {
            return arrayList;
          } 
        }  
      arrayList.add(a(null.getStringArray(paramInt)));
      return arrayList;
    } finally {
      typedArray.recycle();
    } 
  }
  
  private static List<byte[]> a(String[] paramArrayOfString) {
    ArrayList arrayList = new ArrayList();
    int i = paramArrayOfString.length;
    for (byte b = 0; b < i; b++)
      arrayList.add(Base64.decode(paramArrayOfString[b], 0)); 
    return arrayList;
  }
  
  private static void a(XmlPullParser paramXmlPullParser) {
    for (byte b = 1; b; b++) {
      switch (paramXmlPullParser.next()) {
        default:
          continue;
        case 3:
          b--;
          continue;
        case 2:
          break;
      } 
    } 
  }
  
  private static a b(XmlPullParser paramXmlPullParser, Resources paramResources) {
    paramXmlPullParser.require(2, null, "font-family");
    if (paramXmlPullParser.getName().equals("font-family"))
      return c(paramXmlPullParser, paramResources); 
    a(paramXmlPullParser);
    return null;
  }
  
  private static a c(XmlPullParser paramXmlPullParser, Resources paramResources) {
    TypedArray typedArray = paramResources.obtainAttributes(Xml.asAttributeSet(paramXmlPullParser), a.c.FontFamily);
    String str1 = typedArray.getString(a.c.FontFamily_fontProviderAuthority);
    String str2 = typedArray.getString(a.c.FontFamily_fontProviderPackage);
    String str3 = typedArray.getString(a.c.FontFamily_fontProviderQuery);
    int i = typedArray.getResourceId(a.c.FontFamily_fontProviderCerts, 0);
    int j = typedArray.getInteger(a.c.FontFamily_fontProviderFetchStrategy, 1);
    int k = typedArray.getInteger(a.c.FontFamily_fontProviderFetchTimeout, 500);
    typedArray.recycle();
    if (str1 != null && str2 != null && str3 != null) {
      while (paramXmlPullParser.next() != 3)
        a(paramXmlPullParser); 
      return new d(new a(str1, str2, str3, a(paramResources, i)), j, k);
    } 
    ArrayList arrayList = new ArrayList();
    while (paramXmlPullParser.next() != 3) {
      if (paramXmlPullParser.getEventType() != 2)
        continue; 
      if (paramXmlPullParser.getName().equals("font")) {
        arrayList.add(d(paramXmlPullParser, paramResources));
        continue;
      } 
      a(paramXmlPullParser);
    } 
    return arrayList.isEmpty() ? null : new b((c[])arrayList.toArray(new c[arrayList.size()]));
  }
  
  private static c d(XmlPullParser paramXmlPullParser, Resources paramResources) {
    boolean bool;
    int i;
    TypedArray typedArray = paramResources.obtainAttributes(Xml.asAttributeSet(paramXmlPullParser), a.c.FontFamilyFont);
    if (typedArray.hasValue(a.c.FontFamilyFont_fontWeight)) {
      i = a.c.FontFamilyFont_fontWeight;
    } else {
      i = a.c.FontFamilyFont_android_fontWeight;
    } 
    int k = typedArray.getInt(i, 400);
    if (typedArray.hasValue(a.c.FontFamilyFont_fontStyle)) {
      i = a.c.FontFamilyFont_fontStyle;
    } else {
      i = a.c.FontFamilyFont_android_fontStyle;
    } 
    if (1 == typedArray.getInt(i, 0)) {
      bool = true;
    } else {
      bool = false;
    } 
    if (typedArray.hasValue(a.c.FontFamilyFont_ttcIndex)) {
      i = a.c.FontFamilyFont_ttcIndex;
    } else {
      i = a.c.FontFamilyFont_android_ttcIndex;
    } 
    if (typedArray.hasValue(a.c.FontFamilyFont_fontVariationSettings)) {
      j = a.c.FontFamilyFont_fontVariationSettings;
    } else {
      j = a.c.FontFamilyFont_android_fontVariationSettings;
    } 
    String str1 = typedArray.getString(j);
    int j = typedArray.getInt(i, 0);
    if (typedArray.hasValue(a.c.FontFamilyFont_font)) {
      i = a.c.FontFamilyFont_font;
    } else {
      i = a.c.FontFamilyFont_android_font;
    } 
    int m = typedArray.getResourceId(i, 0);
    String str2 = typedArray.getString(i);
    typedArray.recycle();
    while (paramXmlPullParser.next() != 3)
      a(paramXmlPullParser); 
    return new c(str2, k, bool, str1, j, m);
  }
}
